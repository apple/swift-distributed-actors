
[[actorable]]
== Actorable Actors

> The api:Actorable[protocol] protocol allows for defining Actors by writing structs (or classes),
> and deriving the underlying message-passing machinery from the struct's function declarations.

NOTE: See also <<behaviors, Actor Behaviors>> which describes the underlying power-user API.

=== Getting Started: Actorable

WARNING: api:Actorable[protocol] and `GenActors` are EXPERIMENTAL and may change.
         This source generation tool is aimed to prove the concept of deriving actor message protocols from function declarations,
         which may perhaps be possible to implement using compiler features in the future.

The api:Actorable[protocol] protocol allows for a no-hassle way for defining actor behavior.
By conforming to the protocol all public and internal functions defined directly (not in extensions) in a type
are made available as messages.

[source]
----
include::{dir_sact_doc_tests}/Actorable/ActorableDocExamples.swift[tag=greeter_0]
----

Such struct can be used as synchronous implementation, but can also be spawned as an actor.

Before we spawn the actor, we have to run the `GenActors` command line utility, which analyzes and generates messages,
and supporting actor infrastructure for all Actorable types. To do so, invoke:

[source]
----
swift run --package-path .build/checkouts/swift-distributed-actors GenActors
----

which by default generates actors for all api:Actorable[protocol] types located in the `Sources` directory.
If you want to customize which folders or files to scan for actorables, you can pass them as parameters.
You can also use `--verbose` to print more information about the source code generation.

Once this is done, we are ready to spawn and communicate with our first api:Actor[struct].
Spawning an api:Actor[struct] from an actorable is performed using the `system.spawn` method on api:ActorSystem[class]:

[source]
----
include::{dir_sact_doc_tests}/Actorable/ActorableDocExamples.swift[tag=spawn_greeter]
----
<1> An api:ActorSystem[class] is where all actors are running
<2> Spawn the actor by passing a closure that creates an `Actorable`; The returned type is an `Actor`, wrapping the `Greeter` instance.
<3> The `greet(name:)` call, results in *sending a message* to the greeter actor. It will execute it's `greet` implementation asynchronously, and eventually reply -- which is signified by the `Reply<String>` type.

TIP: The generated sources are always created in a file named with the Actorables name, suffixed with `+GenActor.swift`.
     E.g. generated sources for `Greeter` would be generated into `Greeter+GenActor.swift`.

==== Messaging styles: tell, ask, call

Actors are very general constructs, and can perform many more interaction patterns than plain request/reply calls.

In general Actors support three discrete styles of interactions:

- "tell" -- an uni-directional message pass; which is equivalent to a `Void` returning function.
    * This is the underlying mechanism for all other interactions, and does not by itself exert any backpressure on senders.
      Backpressure mechanisms are built on top of tell communication in the message protocol layer. E.g. with token based flow control,
      similar to how Combine or Reactive Streams achieve this.
    * Actorable example signature: `func printGreeting(name: String)`, i.e. it does not return/reply.
- `ask` -- a general form of asking for a reply. An explicit `ActorRef<Reply>` is sent to the downstream,
  making it possible to pass along the asking reference to another actor, which then eventually replies to the originator _directly_.
    * Actorable example signature: `func greetMe(replyTo: Actor<GreetMe>)` or `func greetMe(replyTo: ActorRef<GreetMe>)`, i.e. we expect the greeting to be sent back to the `replyTo` actor.
- "call" -- calls are the general shape of how api:Actorable[protocol] actors expose their request/reply interactions. I.e. when an actorable
  method "returns a value", it actually is implemented by sending that value back to the calling actor.
    * calls are implemented as a form of asks, though this is done transparently to the user.
    * Actorable example signature: `func greet(name: String) -> Greeting`, or `func greet(name: String) -> EventLoopFuture<Greeting>`,
      meaning we "return" the value we want to reply back with. The calling actor will receive an `Reply<Greeting>` in either case.

[[actorable_context]]
==== Actor<Self>.Context

TIP: The api:Behavior[struct] style offers the `ActorContext<Message>` type to access all actor functionality.
     Its equivalent in Actorable style API is `Actor<Self>.Context` which is also accessible as `Myself.Context` inside an actorable.

The actor context is what allows the actor to find out about its name, spawn other actors, and perform more advanced
tasks such as starting timers or awaiting on tasks to complete.

An api:Actorable[protocol] can obtain its own actor context in two ways, though most usefully, it can get it during spawning:

[source]
----
include::{dir_sact_doc_tests}/Actorable/ActorableDocExamples.swift[tag=spawn_with_context_0]
----
<1> Store the context as a field inside the actor. Be sure to *never* hand the context to other threads or actors, as it is strictly private to the actor itself.
<2>

[source]
----
include::{dir_sact_doc_tests}/Actorable/ActorableDocExamples.swift[tag=spawn_with_context_1]
----
<1> `spawn` has an overload that allows creating the api:Actorable[protocol] using a closure which gets the context passed in.
<2> For single parameter inits accepting the actor's context, you can use this shorthand version of spawning them.

WARNING: When spawning actors, make sure to never close over any mutable shared state in the actorable-creating closure,
         as it could break the promise of state isolation actors rely upon.

Refer to api:Actor.Context[struct] API documentation to learn more, or the <<behaviors>> documentation, as many actor context features are the same.

==== Context.Myself

The `myself` reference can be obtained by using `context.myself`. It is typed as `Myself` (a type alias to `Actor<Self>`), allowing you to pass
it anywhere Actorable-conforming actors may be expected. Learn more about this in <<actorable_protocol_composition>>.

==== Sending messages to myself

When implementing functions inside an actorable it is possible to invoke its functions directly, as well as send messages to `myself`.

Both invocation styles may sometimes be useful. E.g. an asynchronous invocation on `context.myself` is useful to reuse
an internal actor function as part of a few public interface methods, or for scheduling tasks for later execution.
A synchronous execution of an actorable function is as useful as any other function reuse, but that function may also be
exposed for others to call via messaging if it makes sense.

The following example showcases both "self invocation" and "myself call" styles:

[source]
----
include::{dir_sact_doc_tests}/Actorable/ActorableDocExamples.swift[tag=self_invoke]
----
<1> We call the `internalTask()` *synchronously*, directly on the actorable's `self`
<2> In this function we will send a `internalTask` _message_ and want to return its reply, thus the return type changes
<3> We use `context.myself.internalTask()` to *send a message* to `myself`



==== Message Access-Control

#Access control is fairly limited, as we'd realistically want more control, e.g. using some @Actorable on methods.#

Currently, all except a few functions declared on an Actorable type are generated (by <<gen_actors, GenActors>>) as actor messages.
For example, the following Actorable:

[source]
----
include::{dir_sact_doc_tests}/Actorable/ActorableDocExamples.swift[tag=access_control_1]
----

In order to NOT generate a message for a specific function that should be available for your actor, you can:

- prefix it with `__` (double-underscore; as single-underscore sometimes is used for messages which "have to" be public, but really should not be called nor show up in auto completion.)

==== Actorable Lifecycle

Each actor follows a well-defined lifecycle from the moment it is spawned until the moment it terminates.
An actorable can react to those lifecycle events by overriding the `preStart`, `postStop` and `receiveTerminated` functions, like this:

[source]
----
include::{dir_sact_doc_tests}/Actorable/ActorableDocExamples.swift[tag=lifecycle_callbacks]
----
<1> `preStart` executes before any other message is received by the actor, and is a good place to perform any post-init additional initialization work, e.g. scheduling timers or similar.
<2> Note also that the Actor's context is passed into these lifecycle hooks, making it easy to log or perform additional tasks
<3> `postStop` executes after the "last" message that an actor will handle is processed (or the actor is crashing), and before it is finally terminated and `Terminated` signals are sent to any actors which were watching it.
<4> `receiveTerminated` executes whenever a watched actor is terminated (crashes or stops voluntarily), giving this actor a chance to react to that termination (e.g. by terminating itself, or spawning a "replacement" for the now dead actor).

The entire lifecycle is perhaps best explained using the following diagram illustrates lifecycle transitions and signals
which are delivered to an actor as it undergoes these transitions. Note that in normal situations, i.e. without faulty behaviors,
the diagram is a simple linear transition from `Running` through `Stopped` to `Terminated`. All other states and transitions come
into play only in face of faulty behaviors.

#TODO: The diagram and wording are based on the <<behaviors>> documentation, and not yet completely remade for Actorable.#

image::actor_lifecycle.png[Actor Lifecycle]

1. Start: Upon spawning, a special internal `Start` signal is interpreted by the actor, causing the `preStart` callback to execute
2. Stop Myself: An actor may decide to stop itself by returning a api:Behavior[struct,alias='Behavior.stop'], causing it to transition to `Stopped`.
3. Stop by Parent: Alternatively, the current actor's parent parent could send a stop signal (using `context.stop(childRef)`), which the actor would have to abide to.
4. PostStop: Once the actor has `Stopped` and drained its mailbox (to dead letters), it will process one last signal, causing the `postStop` callback to execute
However, regardless of the next behavior returned by handling this signal, the actor will always proceed to the `Terminated` state.
Once `Terminated`, the actor will never again wake up nor process any more messages nor signals.
5. Supervision: If an actor throws an error or causes a fault it will transition to Failing 🔥, and invoke its supervisor will be invoked, to see if the actor should be restated or not.
To learn more about <<Supervision>> and the various supervision strategies, refer to the <<Failure Handling>> chapter of the documentation.
6. Supervision (restart): If the configured supervisor decides that the actor should be restarted (now, or upon a delay), a :api:Signals[enum,alias='Signals.PreRestart'] signal will be delivered to the _current (failing) behavior_,
before a new instance of the _initial behavior_ will be created to replace the faulty one. This means that any state kept enclosed by the faulty behavior will be lost – and the actor can resume operations
from a clean slate, however _while preserving its mailbox and identity_.
7. Supervision (fail): If the supervisor decides that the actor should _not_ be restarted (e.g. because it exhausted its permitted restart count, or the fault captured is too serious to ignore),
the actor will transition to `Stopped` and `Terminated`, similar to how it would behave if it were stopping itself manually. #TODO: I think we want to signal in PostStop that this is because we failed, and not a manual stop#

[[actorable_protocol_composition]]
=== Actorable Protocols & Composition

It is possible to make protocols api:Actorable[protocol] as well, this allows other concrete actorables (such as classes or structs),
to adopt them, and also enables composing multiple message protocols and implementing them in one actor.

TIP: In case you are familiar with behaviors and adapters, this composition style is vastly superior and less boiler-plate heavy.

Let us define two protocols, which will perform two separate sets of tasks, and then we will implement them in the same actorable.

[source]
----
include::{dir_sact_doc_tests}/Actorable/ActorableDocExamples.swift[tag=compose_protocols_1]
----
<1> Create a (public) protocol and make it api:Actorable[protocol]
<2> Boilerplate which we need to provide to allow boxing the `CoffeeMachine` messages in a concrete actor's message protocol (see below)
<3> Create an (internal) protocol and make it api:Actorable[protocol]
<4> Boilerplate which we need to provide to allow boxing the `Diagnostics` messages in a concrete actor's message protocol (see below)
<5> Finally, implement a concrete Actorable, conforming to api:Actorable[protocol] (!) as well as the two protocols we just defined.

Since we intend to use them as actorable protocols, we need to allow any adopter of this protocol to box the protocols messages
into the conforming type's message protocol. #TODO: Hopefully we could work around this somehow less painfully#
In other words, we have to define a special boxing methods in the protocols. If we forget to do so, we will see the following error,
asking us to provide the function declaration (without implementing it, as that is generated) to our protocol(s):

----
[gen-actors] Actorable protocol [CoffeeMachine] MUST define a boxing function, in order to be adopted by other Actorables!
Please define a static boxing function in [CoffeeMachine]:

    static func _boxCoffeeMachine(_ message: GeneratedActor.Messages.CoffeeMachine) -> Self.Message

Implementations for this function will be generated automatically for every concrete conformance of an Actorable and this protocol.
----

Having done this, after invoking <<gen_actors, GenActors>>, we are able to use the `AllInOneMachine` as a `CoffeeMachine`,
or as a `Diagnostics` actor which allows us to print some diagnostics. This is a fairly useful trick in which we keep some
functions internal to our module, yet others public. #Sadly though, since we still generate all messages into the `AllInOneMachine.Message` enum,
effectively they are all public; We should consider if we can improve this, but it'd mean stopping to use enums completely.#

Now let us try out spawning, messaging, and passing around our such defined actor:

[source]
----
include::{dir_sact_doc_tests}/Actorable/ActorableDocExamples.swift[tag=compose_protocols_2]
----
<1> We can send `CoffeeMachine` messages to our `Actor<AllInOneMachine>`
<2> As well as the diagnostics messages
<3> What is more, we can pass our api:Actor[struct] as parameter to any function which needs just a subset of our adopted message
    protocols; e.g. a function `printAnyDiagnostics` which takes any actor implementing the `Diagnostics` protocol

This way of composing actor protocols is very powerful, and allows you to have common protocols for typical tasks,
which many of your actors can implement.

TIP: If you are wondering if you should adopt more protocols in the same actor, or introduce more actors to handle the tasks:
     ask yourself if there is a meaningful asynchronous boundary between the two sets of tasks, or if they require some consistent
     view on some data when performing each their actions. A single actor has stronger consistency and lesser complexity than splitting the tasks
     up into multiple actors, but it also limits the parallelism at which the tasks are performed.

[[gen_actors]]
=== Detailed GenActors usage

The `GenActors` utility generates sources in `*+GenActor.swift` files which pair with each Actorable type you define.
Inspect that file for generated source code.

Using some Actorable type called `Greeter` as an example, here are a few notable aspects of the generated sources:

- `Greeter.Message` refers to the message protocol as defined by the functions on the type.
  - you refer to this type whenever a single message or an `ActorRef` for yourself is needed, i.e. you may offer
    a `myself` reference by using `context.myself.underlying` which will be an `ActorRef<Greeter.Message>
- all public and internal functions get corresponding generated "message" functions, i.e. matching by name.

==== GenActors Limitations

The `GenActors` utility is only a proof of concept right now, and as such has some limitations, most notably:

- nested types are not supported, i.e. nesting an actorable struct in another struct or class will not work.

==== Actor Behaviors Inter-Op

It is possible to interop with behaviors from actorable funcs, i.e. it is possible to define a function like:

[source]
----
func initialize(task: Task) -> Behavior<Self.Message>
----

==== Advanced GenActors Usage


The `GenActors` tool allows for defining actors as if they were any normal struct, and by analysing their function declarations,
generating a matching message protocol. api:Actorable[protocol] types are able to be spawned as api:Actor[struct]s, which turn
what looks to be method calls into.

When depending on Distributed Actors in your `Package.swift` file, like so:

[source]
----
.package(url: "https://github.com/apple/swift-distributed-actors.git", from: "$version"),
----

The project will be checked out and available in `.build/checkouts/swift-distributed-actors`, thus is it possible to use the
`GenActors` command line tool by invoking:

[source]
----
swift run --package-path .build/checkouts/swift-distributed-actors GenActors
----

The GenActors command by default inspects the `Sources` directory for files which end with `+Actorable.swift`,
and applies source generation on them. Optionally, you may pass folder paths or file names.

=== Actorables and Serialization

#TODO: This needs a rehaul of the serialization story as we want them to automatically "just work".#

Currently no special codegen is enabled for Actorables, so in order to send messages to other processes or nodes,
you will have to register serializers same as in the behavior style, see: <<serialization>>.

When your actorable is called `Greeter` the generated messages are defined as `Greeter.Message`, and that is the type you will have
to invoke `system.serialization.registerSerializer()` for.
