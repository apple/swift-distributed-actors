
[[actorable]]
== Actorable Actors

> The api:Actorable[protocol] protocol allows for defining Actors by writing structs (or classes),
> and deriving the underlying message-passing machinery from the struct's function declarations.

NOTE: See also <<behaviors, Actor Behaviors>> which describes the underlying power-user API.

=== Getting Started: Actorable

WARNING: api:Actorable[protocol] and `GenActors` are EXPERIMENTAL and may change.
         This source generation tool is aimed to proof the concept of deriving actor message protocols from function declarations,
         which may perhaps be possible to implement using compiler features in the future.

The api:Actorable[protocol] protocol allows for an no-hassle way for defining actor behavior.
By conforming to the protocol all public and internal functions of a type defined in it directly (not in extensions),
are made available as messages.

[source]
----
include::{dir_sact_doc_tests}/Actorable/ActorableDocExamples.swift[tag=greeter_0]
----

Such `struct` can be used as synchronous implementation, but can also be spawned as an actor.

Before we spawn the actor, we have to run the `GenActors` command line utility, which analyzes and generates messages,
and supporting actor infrastructure for all Actorable types. To do so, we can invoke:

[source]
----
swift run --package-path .build/checkouts/swift-distributed-actors GenActors
----

which by default generates actors for all api:Actorable[protocol] types located in the Sources directory.
If you want to customize which folders or files to scan for actorables, you can pass them as parameters.
You can also use `--verbose` to print more information about the source code generation.

Once this is done, we are ready to spawn and communicate with our first api:Actor[struct].
Spawning an api:Actor[struct] from an actorable is performed using the `system.spawn` method on api:ActorSystem[class]:

[source]
----
include::{dir_sact_doc_tests}/Actorable/ActorableDocExamples.swift[tag=spawn_greeter]
----
<1> An api:ActorSystem[class] is where all actors are running
<2> Spawn the actor by passing a closure that creates an `Actorable`; The returned type is an `Actor`, wrapping the `Greeter` instance.
<3> The `greet(name:)` call, results in *sending a message* to the greeter actor. It will execute it's `greet` implementation asynchronously, and eventually reply -- which is signified by the `Reply<String>` type.

TIP: The generated sources are always created in a file named with the Actorables name, suffixed with `+GenActor.swift`.
     E.g. generated sources for `Greeter` would be generated into `Greeter+GenActor.swift`.

==== Messaging styles: tell, ask, call

Actors are very general constructs, and can perform many more interaction patterns than plain request/reply calls.

In general Actors support three discrete styles of interactions:

- "tell" -- an uni-directional message pass; which is equivalent to a `Void` returning function.
    * this is the underlying mechanism for all other interactions, and does not by itself exert any backpressure on senders;
      Backpressure mechanisms are built on top of tell communication, on the message protocol layer, e.g. with token based flow control,
      similar to how Combine or Reactive Streams achieve this.
    * Actorable example signature: `func printGreeting(name: String)`, i.e. it does not return/reply.
- `ask` -- a general form of asking for a reply, however, unlike "calling", when asking an explicit `ActorRef<Reply>` is sent to the downstream,
  making it possible to instead of replying, pass along the asking reference to another actor which then eventually replies to the originator _directly_.
    * Actorable example signature: `func greetMe(replyTo: Actor<GreetMe>)` or `func greetMe(replyTo: ActorRef<GreetMe>)`, i.e. we expect the greeting to be sent back to the `replyTo` actor.
- "call" -- calls are the general shape of how api:Actorable[protocol] actors expose their request/reply interactions. I.e. when an actorable
  method "returns a value", it actually is implemented by sending that value back to the calling actor.
    * calls are usually implemented as a form of asks, though this is done transparently to the user.
    * Actorable example signature: `func greet(name: String) -> Greeting`, or `func greet(name: String) -> EventLoopFuture<Greeting>`,
      meaning we "return" the value we want to reply back with. The calling actor will receive an `Reply<Greeting>` in either case.

[[actorable_context]]
==== Actor<Self>.Context

TIP: The api:Behavior[struct] style offers the `ActorContext<Message>` type to access all actor functionality.
     Its equivalent in Actorable style API is `Actor<Self>.Context` which is also accessible as `Myself.Context` inside an actorable.

The actor context is what allows the actor to find out about its name, spawn other actors and also perform more advanced
tasks such as starting timers or awaiting on tasks to complete.

An api:Actorable[protocol] can obtain its own actor context in two ways, though most usefully, it can get it during spawning:

[source]
----
include::{dir_sact_doc_tests}/Actorable/ActorableDocExamples.swift[tag=spawn_with_context]
----


Refer to api:Actor.Context[struct] API documentation to learn more, or the <<behaviors>> documentation, as many actor context features are the same.

==== Message Access-Control

#Access control is fairly limited, as we'd realistically want more control, e.g. using some @Actorable on methods.#

Currently, all except a few functions declared on an Actorable type are generated (by <<gen_actors, GenActors>>) as actor messages.
For example, the following Actorable:

[source]
----
include::{dir_sact_doc_tests}/Actorable/ActorableDocExamples.swift[tag=access_control_1]
----

In order to NOT generate a message for a specific function that should be available for your actor, you can:

- prefix it with `__` (double-underscore; as single-underscore sometimes is used for messages which "have to" be public, but really should not be called nor show up in auto completion.)

=== Actorable Protocols & Composition

It is possible to make protocols api:Actorable[protocol] as well, this allows other concrete actorables (such as classes or structs),
to adopt them, and also enables composing multiple message protocols and implementing them in one actor.

TIP: If you are familiar with behaviors and adapters, then this composition style is vastly superior and less boiler-plate heavy.

Let us define two protocols, which will perform two separate sets of tasks, and then we will implement them in the same actorable.

[source]
----
include::{dir_sact_doc_tests}/Actorable/ActorableDocExamples.swift[tag=compose_protocols_1]
----
<1> Create a (public) protocol and make it api:Actorable[protocol]
<2> Boilerplate which we need to provide to allow boxing the `CoffeeMachine` messages in an concrete actor's message protocol (see below)
<3> Create an (internal) protocol and make it api:Actorable[protocol]
<4> Boilerplate which we need to provide to allow boxing the `Diagnostics` messages in an concrete actor's message protocol (see below)
<5> Finally, implement a concrete Actorable, conforming to api:Actorable[protocol] (!) as well as the two protocols we just defined.

Since we intend to use them as actorable protocols, we need to allow any adopter of this protocol to box the protocols messages,
into the conforming types message protocol. #TODO: Hopefully we could work around this somehow less painfully#
In other words, we have to define a special boxing methods in the protocols, if we forget to do so, we will see the following error,
asking us to provide the not function declaration (without implementing it, as that is generated) to our protocol(s):

----
[gen-actors] Actorable protocol [CoffeeMachine] MUST define a boxing function, in order to be adopted by other Actorables!
Please define a static boxing function in [CoffeeMachine]:

    static func _boxCoffeeMachine(_ message: GeneratedActor.Messages.CoffeeMachine) -> Self.Message

Implementations for this function will be generated automatically for every concrete conformance of an Actorable and this protocol.
----

Having done this, after invoking <<gen_actors, GenActors>>, we are able to use the `AllInOneMachine` as a `CoffeeMachine`,
or as a `Diagnostics` actor which allows us to print some diagnostics. This is a fairly useful trick in which we keep some
functions internal to our module, yet others public. #Sadly though, since we still generate all messages into the `AllInOneMachine.Message` enum,
effectively they are all public; We should consider if we can improve this, but it'd mean stopping to use enums completely.#

Now let us try out spawning, messaging, and passing around our such defined actor:

[source]
----
include::{dir_sact_doc_tests}/Actorable/ActorableDocExamples.swift[tag=compose_protocols_2]
----
<1> We can send `CoffeeMachine` messages to our `Actor<AllInOneMachine>`
<2> As well as the diagnostics messages
<3> What is more, we can pass our api:Actor[struct] as parameter to any function which needs just a subset of our adopted message
    protocols; e.g. a function `printAnyDiagnostics` which takes any actor implementing the `Diagnostics` protocol

This way of composing actor protocols is very powerful, and allows you to have common protocols for typical tasks,
which many of your actors can implement.

TIP: If you are wondering if you should adopt more protocols in the same actor, or introduce more actors to handle the tasks:
     ask yourself if there is a meaningful asynchronous boundary between the two sets of tasks, or if they require some consistent
     view on some data when performing each their actions. A single actor has stronger consistency and lesser complexity than splitting the tasks,
     up into multiple actors, but it also is limiting the parallelism at which the tasks are performed.

[[gen_actors]]
=== Detailed GenActors usage

The `GenActors` utility generates sources in `*+GenActor.swift` files which pair with each Actorable type you define.
In order to inspect what sources were generated, simply refer to that file.

Notable aspects of the generated sources, for some Actorable type called `Greeter`, the following is true:

- `Greeter.Message` refers to the message protocol as defined by the functions on the type.
  - you refer to this type whenever a single message or an `ActorRef` for yourself is needed, i.e. you may offer
    a `myself` reference by using `context.myself.underlying` which will be an `ActorRef<Greeter.Message>
- all public and internal functions get generated functions that correspond to their messages, i.e. matching by name.

==== GenActors Limitations

The `GenActors` utility is only a proof of concept right now, and as such has some limitations, most notably:

- nested types are not supported, i.e. nesting an actorable struct in another struct or class will not work.

==== Actor Behaviors Inter-Op

It is possible to interop with behaviors from actorable funcs, i.e. it is possible to define a function like:

[source]
----
func initialize(task: Task) -> Behavior<Self.Message>
----

==== Advanced GenActors Usage


The `GenActors` tool allows for defining actors as if they were any normal struct, and by analysing their function declarations,
generating a matching message protocol. api:Actorable[protocol] types are able to be spawned as api:Actor[struct]s, which turn
what looks to be method calls into.

When depending on Distributed Actors in your `Package.swift` file, like so:

[source]
----
.package(url: "https://github.com/apple/swift-distributed-actors.git", from: "$version"),
----

The project will be checked out and available in `.build/checkouts/swift-distributed-actors`, thus is it possible to use the
`GenActors` command line tool by invoking:

[source]
----
swift run --package-path .build/checkouts/swift-distributed-actors GenActors
----

The GenActors command by default inspects the `Sources` directory for files which end with `+Actorable.swift`,
and applies source generation on them. Optionally, you may pass folder paths or file names

=== Actorables and Serialization

#TODO: This needs a rehaul of the serialization story as we want them to automatically "just work".#

Currently no special codegen is enabled for Actorables, so in order to send messages to other processes or nodes,
you will have to register serializers same as in the behavior style, see: <<serialization>>.

When your actorable is called `Greeter` the generated messages are defined as `Greeter.Message`, and that is the type you will have
to invoke `system.serialization.registerSerializer()` for.
