
== Clustering ✗

> One actor is no actor, they come in systems.

=== Configuration

#TODO: Add more configuration documentation#

==== Joining nodes

In order for actors to be able to communicate across nodes, the nodes they reside one have to form a cluster (with exceptions,
#TODO: ServiceRefs are the exception#).

Forming a cluster is fairly simple, and consists of a few lines of configuration and joining nodes to appropriate addresses:

[source]
----
include::{dir_sact_doc_tests}/ClusterDocExamples.swift[tag=joining]
----
<1> Enable clustering (so the node binds to a local port and begins listening for connections), and optionally change which address to bind to.
<2> Join the other node, forming a 2 node cluster. The address could be discovered using some mechanism, or known up front and configured into the app. #TODO to be replaced with discovery mechanism / seed nodes#

Once the nodes have established connections, you are ready to transparently send messages across the network.

#TODO serialization first though...? or we first show that we have some built in types and THEN show serialization.#

#TODO proper intro and diagram of how nodes join#

NOTE: In some situations it may happen that a node crashes and comes up again using the same address (system name, host and port)
      and attempts to re-connect to an existing cluster. While the cluster would eventually detect the "previous incarnation"
      of this node as crashed, the restarted one _may_ be faster to attempt a join than the failure detector triggering the downing
      of the old node.

      In these situations, the "new incarnation" causes the immediate downing and removal of the previous incarnation
      and "takes its place", however from the clusters perspective, it is not any special node -- it is treated the same way as
      any other freshly joined node (and has to go through the joining steps as any other node would).

=== Receptionist ✗

#TODO#

=== Replicated State Machines ✗

#TODO#

==== TLS

Communication between nodes can be secured with TLS by adding the necessary configuration.

[source]
----
include::{dir_sact_doc_tests}/ClusteringDocExamples.swift[tag=config_tls]
----
<1> TLSConfiguration is contained in the NIOSSL module
<2> We need to provide a path the a certificate chain
<3> And private key
<4> Certificate verification is optional and can be set to `.none` for no verification
<5> When using self signed certificates, set the trust to a certificate chain containing the certificates of all nodes that this node will be communicating with

NOTE: The server side connection will use `.noHostnameVerification`, even when `.fullVerification` is configured, as we don't know which nodes we'll be communicating with.

If the private key is protected with a passphrase, a passphrase callback has to be configured. The callback has a single parameter, that is the setter for the passphrase,
which has to be called with the passphrase encoded as `[UInt8]`.

[source]
----
include::{dir_sact_doc_tests}/ClusteringDocExamples.swift[tag=config_tls_passphrase]
----
