
== Actors

> Actors provide a higher level of abstraction for building concurrent and distributed systems.
>
> They are a fundamental building block of the http://en.wikipedia.org/wiki/Actor_model[Actor Model],
> published by Carl Hewitt in 1973, but since gained popularity thanks to numerous implementations of the model.


Welcome to Swift Distributed Actors Actors, a _type-safe_ implementation of the Actor Model for Swift.

=== Thinking in Actors

In order to build systems successfully using actors first you will need to get into the right mindset.
In this section we will try to guide you towards "thinking in actors," but perhaps it's also best to first realize that:
"you probably already know actors!" As any time you implemented some form of identity that was fed tasks that it should
work on, most likely using some concurrent queue or other synchronization mechanism, you probably almost invented some form of actor-like structures there yourself ðŸ˜Š

Actors are a relatively low-level concurrency and distribution abstraction, modeled after how communication in the real world
happens: via asynchronous message passing. Actors take this observation and make it the core principle of anything built using them:

> **Rule 1: Actors communicate only using messages.**

Which is the single most important difference between actors and other concurrency styles. Actors communicate by sending
messages to each other's mailboxes, and processing messages from their own mailboxes.

This abstraction is very powerful and enables all core features of actors, namely:

* handling concurrency without the need of thinking about threads or specific queues -- one only has to think about sending messages to specific identities;
  ** Same as in real life: we only need to care about whom to send that important email, not about all the details how to safely get that email delivered to them!
* being able to send messages to actors _the same way_, regardless if they are located on the same machine, on another clustered node, or potentially even somewhere completely different.
  ** This is sometimes referred to as "location transparency," as we do not need to know about the physical location of the actor, as long as we have a reference to it.


> **Rule 2: Actors can `spawn` other actors**

Similarly to threads, processes, isolates or other isolation mechanisms, actors can create (or "spawn" in actor terminology)
other actors. This is a very useful capability as a single actor does not by itself give any parallelism to processing of messages,
as it always processes one message at a time. In order to distribute work to be processed in parallel we want to use multiple actors,
with each working on a piece or chunk of a lager work item. Or another way to view this is that if we represent users of our system
by an actor each -- we get parallelism in processing across all the users/actors, however each user/actor, is going to process
its own pieces of work in a linear fashion.

A typical example where spawning _child_ actors comes in handy is splitting up a bigger piece of work into smaller ones and having the parent coordinate this work being done. Examples of such tasks include simulations, rendering tasks or simply tasks which consist of many smaller tasks. Actors also fit very well for modeling anything that has identity and makes some independent decisions based on the outside world's signals, like for example units and CPU "players" in games.

Another typical use case for being able to spawn millions of actors on a single machine, as opposed to threads,
is the ability to use them to map real world identities, such as devices, measurements or people to their actor "counterpart,"
inside of our actor application. This helps understandability and traceability when "things go wrong," as we can more easily
trace back faults to perhaps a given user's dataset or message sequence that caused a crash.

> **Rule 3: Actors can change their behavior in reaction to a message**.

An Actor's _raison d'Ãªtre_ can be formulated as: encapsulating state and protecting it from the complicated concurrent world out there.
Actors enable us to write advanced concurrent and distributed applications by offering us a simple mental model: an
actor processes a message, and the next time it receives a message, it may react differently than before , since the previous message
has changed its behavior. It is perhaps easier explained if we think about changing state. If an incoming message changed an actor's
state, such as a counter, the next message would be handled depending on the new counter's state. In other words, state changes manifest
in changes in an actor's behavior.

In Swift Distributed Actors we model Behaviors explicitly, as they are not only state changes, but also runtime affecting behaviors, such as
stopping or suspending the actor, ignoring, dropping or combining message handlers as "the next behavior." We will learn more about
behaviors in the following sections.

==== What Actors are **_not_**?

Actors are not aimed to solve _all_ concurrency tasks, nor do they replace Futures or async/await based models.

In fact, they complement them -- as Futures or async/await are excellent ways to model the flow of data or avoid callbacks,
however, they do not provide addressable identities which are able to _keep state_ and communicate over the network -- and this is where actors excel at.

In other words: actors are focused on identity, state, and distribution thereof.


==== Design for Failure

We should avoid "omg everything as an actor!" when people start adopting this :-)

==== Actors are asynchronous boundaries, not _everything_ needs such boundary

Take care to not fall into the "every single thing must be an actor" fallacy while learning and using actors in your project.

Actors have a specific purpose, and much like not every single operation in your program is starting new threads and performing work asynchronously,
not all things have to be expressed as actor messages.

Consider the following situation: an actor accepting a `SummarizeBill` message, which will cause the actor calculate the total amount

=== Using Actors

In this section, we will learn the basics of using actors to implement simple messaging patterns.

==== Defining Messages

Before we dive in head-first into defining our actors, let's focus for a second what in reality might be the most
important aspect of working with them, to begin with: defining message protocols.

While swift-distributed-actors does not limit what types of messages you can send between actors, you should keep in mind that you are
working with inherently concurrent entities, and as such care should be taken to _not_ share any mutable references inside
your messages. In order of preference (from best to worst) you should try to define messages using the following style:

- as (deeply immutable) value types ^(best)^ -- e.g. as `structs` or `enums` which contains only other value types,
- as value types -- which do contain references to non-value types, however, those are either immutable, or thread-safe to access,
- as immutable reference types -- as even if it is a reference type, you still guarantee that they won't be mutated accidentally by multiple actors at the same time,
- as general reference types ^(worst;^ ^highly^ ^error^ ^prone)^ -- this is best avoided, as it can easily lead to accidentally sharing mutable references which may lead to concurrent access to those fields by multiple actors.

In general, it is best to keep messages sent between actors just that: plain messages.
Avoid sending closures as part of messages, as you may accidentally introduce race conditions by means of closing over some shared mutable reference in such closure.

#Internal note: While it would be lovely if we could require them to be "copyable". Similar to Rust's https://doc.rust-lang.org/std/marker/trait.Send.html[`Send`].#

TIP: Messages SHOULD be immutable values. Prefer structs and enumerations wherever possible.

#TODO: Add link to serialization engine docs once we have it.#

#TODO: There should be another section eventually about designing message protocols.#


==== Defining Actor Behaviors

Actors are _always_ defined by the api:Behavior[struct] that they are running (or "acting out" if you want to take the actor analogy one step further).

Two main "styles" of defining actor behaviors are available:
  - one being "class-oriented" in which mutable state is stored within an actor's behavior `class`

Generally speaking the functional style is recommended as it allows for cleaner designs and forces the definition of more
understandable state _named_ transitions, rather than protecting a "bunch of state" with the actor message handling mechanisms.

TIP: The function-oriented style is preferable as it leads to cleaner, smaller single-purpose behaviors,
     which are combined into small state machine-like constructs by becoming another behavior whenever the actors state needs to change.

For some actors (or teams) the class-oriented style may however feel more natural, and while we recommend the more functional style,
either styles can be successfully used to build distributed applications.

NOTE: It _is_ possible to mix and match behaviors defined in either styles, even the same actor may become a class-oriented
      behavior from a functional-style one and vice versa. This may come in handy for some states in an actor's lifecycle
      which can be nicely expressed in one of the styles, but not necessarily the other.

You might be surprised to find out that there is no "Actor" class to extend from in Swift Distributed Actors. #TODO fixme wording here..#
This is because conceptually and Actor is the sum of three parts:

1. A `Mailbox` containing all the pending messages that the actor should process
2. A api:Behavior[struct]  that should be run for each subsequent message.
3. A api:MessageDispatcher[protocol] which "runs the Actor".

===== Behaviors defined in `class`-oriented style

To many developers, the more familiar way of defining api:Behavior[struct] is likely going to be the `class`-oriented style.
While we consider this state to lead into sharing too much state between the various states an actor can reside in,
we do acknowledge that the familiarity of this way of defining actors is a nice entry path to working with actors.

To define a simple behavior that will extend a `class` you can:

[source]
----
include::{dir_sact_doc_tests}/ActorDocExamples.swift[tag=classOriented_behavior]
----
<1> Extend the `ClassBehavior` base class #TODO: Maybe we call it ClassBehavior, so it's the class-oriented one? Want to avoid this being the only place with Actor in name of behavior#
<2> Implement the `receive` function; it will be invoked using the actors' context and arriving message for every message sent to this actor
<3> Do something with the message, e.g. print it
<4> Return the "next behavior" which this actor should _become_. Our actor is simple and stable in its behavior, thus it can return the special `Behavior.same`.

We can extend this actor to have some internal state, that it will keep mutating upon receipt of a message:

[source]
----
include::{dir_sact_doc_tests}/ActorDocExamples.swift[tag=classOriented_behaviorWithState]
----
<1> A class-oriented actor behavior can have stored properties which it is safe to modify during a _reduction_
<2> We increment the local counter for every message that we receive; Even though we may run these on various threads, proper synchronization is in place.

Messages will be processed one-by-one by the actor, and the _thread_ which the actor uses to run these _reductions_ MAY change in between reductions.
However, the thread-safety of accessing the actors stored property is guaranteed thanks to how actors are scheduled.

Effectively, within an actor you can work as-if it was a single threaded application. The same applies for the function-oriented style as well,
which we'll explore in the following section.

===== Behaviors defined in function-oriented style

Those three elements together form one functioning actor. In other words, an actor is a behavior that is able to be run
with messages from a mailbox. It is by design that the actor itself cannot be seen nor reached from user code, this
allows Swift Distributed Actors to provide the memory isolation safety that actors are known for -- i.e. there is

Another reason is, that semantically, it is not possible to "combine actors" as they are their own individual entities
and always have to guarantee isolation from any 3rd parties. However, it is possible and tremendously useful to combine
actor `Behaviors`.

TIP: All actors are defined in terms of their api:Behavior[struct].

For getting started, we'll focus on the most important behavior group, the `receive` functions, as they allow an
actor to react to messages. The `receive` behavior comes in a few different flavors. Firstly, the `receiveMessage`
is one of the more useful versions as it allows us to simply react on a message, and return the next behavior that the
actor should _become_:

[source]
----
include::{dir_sact_doc_tests}/ActorDocExamples.swift[tag=receiveMessage_behavior]
----
<1> Defines a reusable behavior that can receive `Greetings` messages. You can `spawn` multiple actors of the same behavior after all.
<2> We do something with the message; here we only print it, but things will soon be much more exciting.
<3> Lastly we return the "next behavior", since all behaviors are small state machines.

As you can see, this already defines a mini state machine, albeit not a very interesting one, as the behavior will
continuously become the `.same` one.


You might be curious how the message type looks like, now that we've seen a behavior to handle them.
In our example we do not yet worry about the serialization of the messages, so it can be in fact any type,
however we strongly recommend

==== Spawning Actors

TIP: Starting actors is referred to as "spawning" them. In the same way one refers to spawning new threads by a thread pool or operating system.


[source]
----
include::{dir_sact_doc_tests}/ActorDocExamples.swift[tag=spawn]
----
<1> All Actors "live" within an `ActorSystem`, so in order to work with actors we need to first start a system.
<2> An actor's "Behavior" contains all the logic and state that it will work with. There are numerous ways to define one, we'll learn about them very soon.
<3> We `spawn` our actor using the `behavior` and we give it a `name` while we are at it as well. Names are tremendously helpful for understanding and debugging your application.

==== Sending messages

Sending messages to actors is straight forward and can be done thanks to the api:ActorRef[class]`.tell(_:)` method.

#TODO: ActorRef link should be ActorRef<Message>#

For example, now that we have obtained a reference to

[source]
----
include::{dir_sact_doc_tests}/ActorDocExamples.swift[tag=tell_1]
----
<1> We _tell_ our actor our name, so that it can greet us. This is an asynchronous fire-and-forget message send to the actor.

TIP: Sending messages to actors always has the same form, regardless if they are local or remote.
     (This is one of the ways the _location transparency_ property surfaces in the APIs.)

#TODO: complete this section#

=== Stopping actors

#TODO: Diagram of actor lifecycle#

==== Guarantees

For a given actor, the following is guaranteed:

- if an actor returns the `.stopped` behavior, no further messages will be delivered to its message (or signal) receive blocks.
- if any other actors have been watching this actor, they will be informed about its termination using `.terminated` messages.

Internal guarantees:

- if the `.stopped` behavior is returned during handling system messages, no further user messages shall be processed.
- all pending (system) already enqueued to the actors mailboxes messages SHOULD be drained to dead letters or dropped.
- once the `.stopped` behavior is returned the actor should immediately be treated as `TERMINATING` yet it is not yet `CLOSED` (dead),
  - during the time between `TERMINATING` and `CLOSED` the actor performs shut down logic, such as notifying the parent actor or any watchers about its death.
  - all incoming messages, which hit an "at-least-TERMINATING" actor shall be immediately be DROPPED, without being enqueued at all. This is to avoid waking up the actor infinitely.
- resources (e.g. the held behavior) shall only be released once the CLOSED state has been reached.

Parent-child relationships add a few more guarantees:

- a parent is always notified about its child's failures
  - these DO NOT cause it to kill itself
- if the parent spawns AND watches the child though, the same death pact principles apply,
  and a failing child WILL cause the parent to terminate as well.

==== Stopping the Current Actor (Myself)

While an actor is running there exist only two ways in which it may decide end up _stopping itself_, either by:

- stopping: returning a api:Behavior[struct]`.stopped` as the next behavior
- crashing: by throwing an `Error` or causing a fault.
** in which case <<supervision>> will handle the failure and determine what to do about it; by default stopping the actor.

To see this in a more realistic example let's have a look at the following snippet:

[source]
----
include::{dir_sact_doc_tests}/ActorDocExamples.swift[tag=stop_myself_1]
----
<1> We invoke some business logic that does not have to be aware of the actor details at all
<2> We interpret the terminal data chunk to mean that we should now stop, and do so by returning api:Behavior[struct]`.stopped`

This example also showcases that we do not necessarily have to bind the business logic to the fact that it is being executed inside an actor.
As shown in the snippet, we can interpret states returned by the underlying logic as states the actor should transition in its lifecycle.

In practice such snippets would often be extracted into their own functions or extensions onto the domain objects, for example:

[source]
----
include::{dir_sact_doc_tests}/ActorDocExamples.swift[tag=stop_myself_refactored]
----

Note that returning `.stopped` also _guarantees_ that no further messages will be processed after the stopped behavior
has been returned. You may also use the `.stopped(postStop:)` overloads to perform cleanup operations, or even store your
own "stopped" that would perform some cleanup logic if there was a need to do the similar cleanup for various actors in
your system.

NOTE: It is NOT possible to stop yourself by calling the `context.stop(child:)` function to stop `myself`.
      This is to not encourage another way of doing the same thing, and make stopping easier to track -- as it should always result from a `return .stopped` or a failure. This makes analyzing existing code bases simpler, as there are only the two cases to look for.

==== Stopping Child Actors

A parent actor may stop child actors by using `context.stop(child:)` on them,
which is implemented as a system message send asking the child to stop.

The child MAY NOT refuse such stop command and it is effective immediately once the message arrives at the child actor.
Bear in mind though that this stopping operation, by virtue of being a message send, is an asynchronous operation.

#TODO: complete this section#

[[props]]
=== Configuring Actors with Props

api:Props[struct] can be seen as accompanying data to an actors behavior, that is used by Swift Distributed Actors to configure or
apply special handling to the actor once it is started.

TIP: "Props" are what an theater actor may use during a performance. For example, a skull would be a classic example of
     a "prop" used while performing the William Shakespeare's Hamlet Act III, scene 1, saying _"To be, or not to be, that is the question: [...]."_
     In the same sense, api:Props[struct] for Swift Distributed Actors actors are accompanying objects/settings, which help the actor perform its duties.

Props can be defined once and used for starting any number of actors (as they are effectively only immutable "settings").
You can change props by using by mutating the value type

[source]
----
include::{dir_sact_doc_tests}/ActorDocExamples.swift[tag=props_example]
----

Most commonly one would use `Props` to configure an actor's supervision strategy (which is described in more detail in the <<failure_handling>>
section of the guide), or its `dispatcher`.


[[suggested_props_pattern]]
==== Suggested Props Pattern

Sometimes when implementing behaviors which may be spawned by other users, it may be useful to centralize the props creation
along with its default "suggested" settings. The _Suggested Props_ pattern explains a common style in which this can be solved.

The pattern involves exposing, along with a behavior that users may spawn also an api:Props[struct] instance with
pre-configured dispatcher, supervision or other settings.

[source]
----
include::{dir_sact_doc_tests}/ActorDocExamples.swift[tag=suggested_props_pattern]
----

Having that said, this pattern puts more burden on the spawner and specifically should not be used to abuse supervision
as replacement for classical do/catch `Error` handling. If it is known that an actor may encounter some Error it is very
likely more appropriate to handle this using traditional `do/catch` blocks inside the actor, rather than relying on supervision.
Worth pointing out here is that supervision only allows to either restart or stop the actor; no "ignore this error,
everything is actually fine" is allowed, yet such strategy can be implemented using a classical `do/catch` where in the
catch one could log a warning about the "harmless" error having occurred.

=== Actor Paths and Hierarchy

#TODO: explain that by looking at path you know: is it remote? is it someone's child? what's the unique id?#

A feature of actors is that they have _unique identity_, which is represented by their address.
Similar to real life, one can only send messages to an actor or friend if we know their address.

The "sending" capability is expressed by obtaining an api:ActorRef[class], which also contains the actor's address.
There can be many references (even on different nodes in a cluster) to the same actor, however its address remains the same.

The address contains a UID which is sometimes referred to as the "Incarnation" ID. This UID is used to clarify identity in
the following situation:

- an actor is spawned under the `/user/animal/caplin` path;
  - it gains a unique identifier which is appended to its path like this automatically: `/user/animal/caplin#34535`.
- the actor hands out a few references to itself to other actors for future use.
- the actor decides it has performed its task and should now stop itself.
- after the actor stops, the `/user/animal` parent decides that another `caplin` should be spawned, to perform some tasks that Caplins are good at.
  - another _new_ actor is spawned under the _same path_ `/user/animal/caplin` and most likely will perform the same kind of work as the "previous Caplin"
- the new actor resides on the _same path_ however has a _different identity_ (and UID, which represents it)!
- meanwhile, actors who were told about the original Caplin's `ActorRef` decide to send a message to it.
- thanks to the different UID the system knows that these messages are _not_ intended for the _current_ Caplin -- as it has a different identity.
  - note that this matters mostly for distributed systems, since in local systems the identity issue is resolved by simply
    holding references to actor mailboxes; however semantically the model is exactly the same: the "old incarnation" is now gone.
- messages sent to the "old" api:ActorRef[class] are instead piped to the `/system/deadLetters` queue and may be logged for diagnosing potential control flow issues in the application.

=== Locating actors using the Receptionist

The receptionist is a system actor that allows users to register actors under a api:Receptionist.RegistrationKey[struct] so that
it can be looked up in other parts of the system. Usually actor references should be passed around to allow actors to communicate,
but there are cases where this is not convenient or possible. One such example is communication in a cluster. To share a reference
with another node in the cluster, we have to send that reference to it, but that is only possible, if we already have a reference
to an actor on that node. So by registering the actors we want to make accessible from other nodes in the cluster, we have a way
of sharing them by communicating with a local ref only. The registered actors will then automatically be made available on all
nodes in the cluster and can be looked up by sending a message to the local receptionist.

#TODO clustered receptionist is not implemented yet#

*Example*

First we need to register the actor on the node it lives on. This is usually done in the `.setup` behavior.

[source]
----
include::{dir_sact_doc_tests}/ActorDocExamples.swift[tag=receptionist_register]
----
<1> Create the key under which the actor will be registered (can be re-used between calls)
<2> Send `api:Receptionist.Register[struct]` message to receptionist to register the actor

Now we can lookup all actors that are registered under that key.

#TODO: change example to use ask pattern once available #

[source]
----
include::{dir_sact_doc_tests}/ActorDocExamples.swift[tag=receptionist_lookup]
----
<1> Send `api:Receptionist.Lookup[struct]` message to receptionist to get a `api:Receptionist.Listing[struct]` with all registered actors for the key

If we are interested in changes to the registration, e.g. when a registered actor gets unregistered, because it terminated,
or a new one was added, we can subscribe to those changes.

[source]
----
include::{dir_sact_doc_tests}/ActorDocExamples.swift[tag=receptionist_subscribe]
----
<1> Send `api:Receptionist.Subscribe[struct]` message to receptionist to receive an updated `api:Receptionist.Listing[struct]` on every change to the registrations under the key

=== Interop with non-actor code

In any reasonably complex system, different libraries will be used and we need to find ways to make them interact with each other.
Actors are no exception to this. In this chapter we will look at ways to integrate actors nicely with non-actor code, so that
we can use existing APIs from actors and also receive and process responses from actors outside of actor code.

==== Receiving responses from actors in non-actor code

#TODO: Add paragraph about receiving future responses from actors, i.e. ask pattern, once available#

==== Sending results of asynchronous operations to actors

Our code often has to interact with external systems like databases or other services. Those calls are usually being executed
asynchronously and the result is being made available either as an asynchronous result type, like a future, or as parameter
to a callback that needs to be passed in when calling an asynchronous API. Once we have the result, we can send it to an actor,
alternatively converting it to a message that the actor understands beforehand.

[source]
----
include::{dir_sact_doc_tests}/InteropDocExamples.swift[tag=asyncOp_sendResult_dispatch]
----
<1> An actor that expects to receive the result of some asynchronous computation
<2> Computation is being sent to a DispatchQueue
<3> Execute computation
<4> Wrap result in a message and send it to the actor

Another example is calling an asynchronous API from within an actor. We can't modify the internal actor state from within
asynchronous callbacks, because that would create a race condition and also violate the actor model concept of communicating
only through message passing, so instead we have to send a message to the actor from the callback.

[source]
----
include::{dir_sact_doc_tests}/InteropDocExamples.swift[tag=asyncOp_sendResult_insideActor]
----
<1> Execute asynchronous call with callback
<2> Wrap result in a message and send it to the actor
<3> Handle the result in inside the actor

While this is quite convenient, it also means that the response has to be included in the `Message` type the actor understands,
so anyone who holds a reference to that actor can send this message to it.

[source]
----
include::{dir_sact_doc_tests}/InteropDocExamples.swift[tag=asyncOp_sendResult_insideActor_external_api]
----

==== Awaiting asynchronous results in actors

#TODO: Add better description of what problem are we facing and then how to solve it#

In order to avoid having to add internal messages to the public message type, actors offer functionality to process asynchronous results
as a continuation withing the actor itself, so it will be executed withing the same context and in sequence with all the
other messages.

#TODO: Add explanation and example for non-suspending awaitResult, once available#

Some actors need to fetch initial state before they can start processing other messages or need to wait for an asynchronous
result before resuming to process user messages. This can be achieved with the `awaitResult` and `awaitResultThrowing` calls
on `api:ActorContext[class]`. They create a behavior that suspends processing of user messages until the asynchronous result has been
received, or the timeout has expired.

Imagine an actor that understands following message protocol, that allows a user to request adding a prefix to a string:

[source]
----
include::{dir_sact_doc_tests}/InteropDocExamples.swift[tag=asyncOp_awaitResult_enum_Messages]
----

Now if we have that prefix stored in a database, we need to fetch it before we can prefix any strings, but we don't want users to be able to change
the prefix, so we can't add it to the message protocol, but we also can't block inside the actor. Using `awaitResult`, we can fetch the data
asynchronously and after receiving the result, start processing the user requests.

[source]
----
include::{dir_sact_doc_tests}/InteropDocExamples.swift[tag=asyncOp_awaitResult]
----
<1> Call operation that returns a `NIO.EventLoopFuture`
<2> Awaiting the result causes the actor to suspend user message processing, but it keeps processing system messages. So e.g. stopping a suspended actor is still possible.
<3> After successfully retrieving the prefix from the database we can start processing the requests
<4> In case the asynchronous operation fails, we can throw the produced error which will be treated like any error that occurs in the actor.

Most of the time when facing situations where the actor needs the result of an async operation to proceed, failure of the async operation should also crash the actor.
The `awaitResultThrowing` convenience function does just that, and allows us to express the same actor behavior in with slightly less boilerplate:

[source]
----
include::{dir_sact_doc_tests}/InteropDocExamples.swift[tag=asyncOp_awaitResultThrowing]
----

CAUTION: `awaitResult` and `awaitResultThrowing` cause the actor to suspend, meaning it won't process any user messages until it is resumed.
This will lead to growth of the mailbox and can cause significant delays in message processing. Therefore these functions should be
used with caution and only when absolutely necessary and with reasonably small timeouts to avoid problems caused by unresponsive
services.


=== Where to go from here?

This chapter has introduced you to the bare basics of building simple actors, however in reality you will want to utilize
more of their capabilities including failure handling and clustering.

We recommend continuing the read of this guide chapter by chapter, and later on referring to it while you work on your apps.
