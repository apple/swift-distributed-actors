import ArgumentParser
import Foundation
import Markdown

func log(_ log: String, file: String = #fileID, line: UInt = #line) {
    print("[fishy-docs] \(log)")
}

struct Commands {
    static let Namespace = "fishy-docs"
    static let Enable = "\(Namespace):enable"
    static let Disable = "\(Namespace):disable"
    static let Skip = "\(Namespace):skip-next"
}

@main
struct FishyDocsMain: ParsableCommand {
    @Option(help: "Folder containing the docc documentation to scan for fishy-docs")
    var doccFile: String

    @Option(help: "Where to generate the sources")
    var outputFile: String

    mutating func run() throws {
        let fileName = self.doccFile
        let testFileName = self.outputFile

        // we always have to create the target file... since we're a .buildPlugin
        // even if we won't generate anything into it.
        FileManager.default.createFile(atPath: "\(testFileName)", contents: nil)

        guard let doccFileURL = URL(string: "file://\(doccFile)") else {
            log("Failed to parse: \(self.doccFile)")
            return
        }
        let document = try Document(parsing: doccFileURL)

        guard self.usesFishyDocs(document: document, url: doccFileURL) else {
            return
        }

        guard let code = try makeDocsTestCode(document: document, doccFileName: fileName) else {
            return
        }

        log("Writing \(fileName) -> \(testFileName)")
        try code.write(toFile: "\(testFileName)", atomically: true, encoding: .utf8)
    }

    func usesFishyDocs(document: Document, url: URL) -> Bool {
        var detectFishyDocs = DetectFishyDocs()
        detectFishyDocs.visit(document)
        return detectFishyDocs.detected
    }

    func makeDocsTestCode(document: Document, doccFileName: String) throws -> String? {
        assert(!doccFileName.isEmpty)

        guard var name = doccFileName.split(separator: "/").last else {
            return nil
        }
        guard let simpleName = name.split(separator: ".").first else {
            return nil
        }
        name = simpleName

        var concatCodeBlocks = ConcatCodeBlocks(name: String(name))
        concatCodeBlocks.visit(document)

        guard !concatCodeBlocks.code.isEmpty else {
            return nil
        }

        var output = "// ==== Concat CodeBlocks from '\(doccFileName)' -----------------------------\n"
        output += "// DO NOT EDIT THIS FILE AS IT WILL BE RE-GENERATED BY FISHY-DOCS PLUGIN.\n"
        output += "// To edit snippets in this file, edit \(doccFileName) instead.\n"
        output += "\n"
        output += concatCodeBlocks.code

        return output
    }
}

/// Detects a `fishy-docs:enable` `@Comment` in a docc file, enabling the plugin for the given file.
struct DetectFishyDocs: MarkupWalker {
    var detected: Bool = false

    mutating func visitParagraph(_ paragraph: Paragraph) {
        self.detected = self.detected || paragraph.plainText.contains("fishy-docs:enable")
    }
}

struct ConcatCodeBlocks: MarkupWalker {
    var importBlocks: [CodeBlock] = []
    var codeBlocks: [CodeBlock] = []

    /// True if capturing code blocks is enabled
    var includeCodeBlock: Bool = true

    /// Allows for skipping a single code block, followed after the fishy-docs:skip-next
    var skipNextCodeBlock: Bool = false

    /// Name of the file we're compile-testing
    let name: String

    init(name: String) {
        self.name = name
    }

    var code: String {
        var allBlocks = importBlocks
        allBlocks.append(contentsOf: codeBlocks)

        var codeBlockStrings: [String] = []
        for block in importBlocks {
            codeBlockStrings.append(block.code)
        }

        codeBlockStrings.append("func __compileTest_\(self.name)() async throws {")
        for block in codeBlocks {
            var s = "// ==== "

            var fileNameWasSet = false
            if let range = block.range {
                let startLoc = range.lowerBound
                if let fileName = startLoc.source!.pathComponents.split(separator: "/").last?.last {
                    fileNameWasSet = true
                    s += "\(fileName):\(startLoc.line)"
                }
            }

            if !fileNameWasSet {
                s += " <unknown loc>"
            }

            s += " ----------------------------------------\n"
            s += block.code

            codeBlockStrings.append(s)
        }
        codeBlockStrings.append("}") // end of __test()

        return codeBlockStrings.joined(separator: "\n")
    }

    mutating func visitParagraph(_ paragraph: Paragraph) {
        if paragraph.plainText.contains(Commands.Enable) {
            self.includeCodeBlock = true
        } else if paragraph.plainText.contains(Commands.Disable) {
            self.includeCodeBlock = false
        } else if paragraph.plainText.contains(Commands.Skip) {
            self.skipNextCodeBlock = true
            self.includeCodeBlock = false
        }
    }

    mutating func visitCodeBlock(_ codeBlock: CodeBlock) {
        guard !self.skipNextCodeBlock else {
            self.skipNextCodeBlock = false
            return
        }
        guard self.includeCodeBlock else {
            return
        }

        if codeBlock.code.contains("import ") {
            self.importBlocks.append(codeBlock)
        } else {
            self.codeBlocks.append(codeBlock)
        }
    }
}
