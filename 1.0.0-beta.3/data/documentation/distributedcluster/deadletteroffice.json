{"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"final"},{"kind":"text","text":" "},{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"DeadLetterOffice"}],"languages":["swift"],"platforms":["macOS"]}]},{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Dead letters are messages or signals which were unable to be delivered to recipient, e.g. because the recipient"},{"type":"text","text":" "},{"type":"text","text":"actor had terminated before the message could reach it, or the recipient never existed in the first place (although"},{"type":"text","text":" "},{"type":"text","text":"this could only happen in ad-hoc actor path resolve situations, which should not happen in user-land)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note: Does "},{"type":"emphasis","inlineContent":[{"type":"text","text":"not"}]},{"type":"text","text":" point to a “real” actor, however for all intents and purposes can be treated as-if it did."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Obtaining an instance of dead letters is best done by using the "},{"type":"codeVoice","code":"system.deadLetters"},{"type":"text","text":" or "},{"type":"codeVoice","code":"personalDeadLetters"},{"type":"text","text":" methods;"},{"type":"text","text":" "},{"type":"text","text":"however, it should be stressed, that directly interacting with dead letters is not something that should be needed at"},{"type":"text","text":" "},{"type":"text","text":"any point in time in normal user applications, as messages become dead letters automatically when messages are"},{"type":"text","text":" "},{"type":"text","text":"delivered at terminated or non-existing recipients."}]},{"anchor":"Watch-semantics","level":1,"type":"heading","text":"Watch semantics"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Watching the dead letters reference is always going to immediately reply with a "},{"type":"codeVoice","code":"Terminated"},{"type":"text","text":" signal."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is not only to uphold the semantics of deadLetters itself, but also for general watch correctness:"},{"type":"text","text":" "},{"type":"text","text":"watching an actor which is terminated, may result in the "},{"type":"codeVoice","code":"watch"},{"type":"text","text":" system message be delivered to dead letters,"},{"type":"text","text":" "},{"type":"text","text":"in which case this property of dead letters will notify the watching actor that the “watchee” had already terminated."},{"type":"text","text":" "},{"type":"text","text":"In these situations Terminated would be marked as "},{"type":"codeVoice","code":"existenceConfirmed: false"},{"type":"text","text":"."}]},{"anchor":"Dead-References","level":2,"type":"heading","text":"Dead References"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"codeVoice","code":"ActorID"},{"type":"text","text":" pointing to a local actor, yet obtained via clustered communication MAY be resolved as so called “dead reference”."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A dead actor reference is defined by its inherent inability to "},{"type":"emphasis","inlineContent":[{"type":"text","text":"ever"}]},{"type":"text","text":" have a chance to deliver messages to its target actor."},{"type":"text","text":" "},{"type":"text","text":"While rare, such references may occur when a reference to a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"local"}]},{"type":"text","text":" actor is obtained from remote communication, and thus"},{"type":"text","text":" "},{"type":"text","text":"the actor address resolution will perform a lookup, to relate the incoming address with a live actor; during this process"},{"type":"text","text":" "},{"type":"text","text":"if any of the following situations happens, the reference will be considered “dead” (like a “dead link” on an HTML page):"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"the address points to a local actor which does not exist, and thus no messages "},{"type":"emphasis","inlineContent":[{"type":"text","text":"ever"}]},{"type":"text","text":" sent to the such-obtained reference will have a chance of being delivered,"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"address resolution locates a live actor matching the path, but with a different "},{"type":"codeVoice","code":"ActorIncarnation"},{"type":"text","text":";"},{"type":"text","text":" "},{"type":"text","text":"meaning that the “previous incarnation” of the actor, which the address refers to, does no longer exist, and thus no attempts to send messages"},{"type":"text","text":" "},{"type":"text","text":"to the such obtained ref will ever succeed"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"address resolution locates a live actor matching the address, however the expected type does not match the actual type of the running actor (!);"},{"type":"text","text":" "},{"type":"text","text":"to protect the system from performing unsafe casts, the a dead ref will be yielded instead of the wrongly-typed ref of the alive actor."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"this can happen when somehow message types are mixed up and signify an actor has another type than it has in the real running system"}]}]}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Dead references are NOT used to signify that an actor that an "},{"type":"codeVoice","code":"_ActorRef"},{"type":"text","text":" points to has terminated and any "},{"type":"emphasis","inlineContent":[{"type":"text","text":"further"}]},{"type":"text","text":" messages sent to it will"},{"type":"text","text":" "},{"type":"text","text":"result in dead letters. The difference here is that in this case the actor "},{"type":"emphasis","inlineContent":[{"type":"text","text":"existed"}]},{"type":"text","text":" and the "},{"type":"codeVoice","code":"_ActorRef"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"was valid"}]},{"type":"text","text":" at some point in time."},{"type":"text","text":" "},{"type":"text","text":"Dead references on the other hand have never, and will never be valid, meaning it is useful to distinguish them for debugging and logging purposes,"},{"type":"text","text":" "},{"type":"text","text":"but not for anything more – users shall assume that their communication is correct and only debug why a dead reference appeared if it indeed does happen."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/distributedcluster\/deadletteroffice"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/DistributedCluster\/documentation\/DistributedCluster\/DeadLetterOffice","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Special actor ref personality, which can handle "},{"type":"codeVoice","code":"DeadLetter"},{"type":"text","text":"s."}],"kind":"symbol","metadata":{"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"DeadLetterOffice"}],"title":"DeadLetterOffice","roleHeading":"Class","role":"symbol","symbolKind":"class","externalID":"s:18DistributedCluster16DeadLetterOfficeC","modules":[{"name":"DistributedCluster"}],"navigatorTitle":[{"kind":"identifier","text":"DeadLetterOffice"}]},"hierarchy":{"paths":[["doc:\/\/DistributedCluster\/documentation\/DistributedCluster"]]},"references":{"doc://DistributedCluster/documentation/DistributedCluster/DeadLetterOffice":{"role":"symbol","title":"DeadLetterOffice","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"DeadLetterOffice"}],"abstract":[{"type":"text","text":"Special actor ref personality, which can handle "},{"type":"codeVoice","code":"DeadLetter"},{"type":"text","text":"s."}],"identifier":"doc:\/\/DistributedCluster\/documentation\/DistributedCluster\/DeadLetterOffice","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"DeadLetterOffice"}],"url":"\/documentation\/distributedcluster\/deadletteroffice"},"doc://DistributedCluster/documentation/DistributedCluster":{"role":"collection","title":"DistributedCluster","abstract":[{"type":"text","text":"A peer-to-peer cluster actor system implementation for Swift."}],"identifier":"doc:\/\/DistributedCluster\/documentation\/DistributedCluster","kind":"symbol","type":"topic","url":"\/documentation\/distributedcluster"}}}