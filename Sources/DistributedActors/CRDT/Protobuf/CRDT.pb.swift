// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: CRDT/CRDT.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Distributed Actors open source project
//
// Copyright (c) 2019-2020 Apple Inc. and the Swift Distributed Actors project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.md for the list of Swift Distributed Actors project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct ProtoCRDTIdentity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ProtoCRDTVersionContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var versionVector: ProtoVersionVector {
    get {return _storage._versionVector ?? ProtoVersionVector()}
    set {_uniqueStorage()._versionVector = newValue}
  }
  /// Returns true if `versionVector` has been explicitly set.
  public var hasVersionVector: Bool {return _storage._versionVector != nil}
  /// Clears the value of `versionVector`. Subsequent reads from it will return its default value.
  public mutating func clearVersionVector() {_uniqueStorage()._versionVector = nil}

  public var gaps: [ProtoVersionDot] {
    get {return _storage._gaps}
    set {_uniqueStorage()._gaps = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ProtoCRDTVersionedContainer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var replicaID: ProtoVersionReplicaID {
    get {return _storage._replicaID ?? ProtoVersionReplicaID()}
    set {_uniqueStorage()._replicaID = newValue}
  }
  /// Returns true if `replicaID` has been explicitly set.
  public var hasReplicaID: Bool {return _storage._replicaID != nil}
  /// Clears the value of `replicaID`. Subsequent reads from it will return its default value.
  public mutating func clearReplicaID() {_uniqueStorage()._replicaID = nil}

  public var versionContext: ProtoCRDTVersionContext {
    get {return _storage._versionContext ?? ProtoCRDTVersionContext()}
    set {_uniqueStorage()._versionContext = newValue}
  }
  /// Returns true if `versionContext` has been explicitly set.
  public var hasVersionContext: Bool {return _storage._versionContext != nil}
  /// Clears the value of `versionContext`. Subsequent reads from it will return its default value.
  public mutating func clearVersionContext() {_uniqueStorage()._versionContext = nil}

  public var elementByBirthDot: [ProtoVersionDottedElementEnvelope] {
    get {return _storage._elementByBirthDot}
    set {_uniqueStorage()._elementByBirthDot = newValue}
  }

  public var delta: ProtoCRDTVersionedContainerDelta {
    get {return _storage._delta ?? ProtoCRDTVersionedContainerDelta()}
    set {_uniqueStorage()._delta = newValue}
  }
  /// Returns true if `delta` has been explicitly set.
  public var hasDelta: Bool {return _storage._delta != nil}
  /// Clears the value of `delta`. Subsequent reads from it will return its default value.
  public mutating func clearDelta() {_uniqueStorage()._delta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ProtoCRDTVersionedContainerDelta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var versionContext: ProtoCRDTVersionContext {
    get {return _storage._versionContext ?? ProtoCRDTVersionContext()}
    set {_uniqueStorage()._versionContext = newValue}
  }
  /// Returns true if `versionContext` has been explicitly set.
  public var hasVersionContext: Bool {return _storage._versionContext != nil}
  /// Clears the value of `versionContext`. Subsequent reads from it will return its default value.
  public mutating func clearVersionContext() {_uniqueStorage()._versionContext = nil}

  public var elementByBirthDot: [ProtoVersionDottedElementEnvelope] {
    get {return _storage._elementByBirthDot}
    set {_uniqueStorage()._elementByBirthDot = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ProtoCRDTGCounter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var replicaID: ProtoVersionReplicaID {
    get {return _storage._replicaID ?? ProtoVersionReplicaID()}
    set {_uniqueStorage()._replicaID = newValue}
  }
  /// Returns true if `replicaID` has been explicitly set.
  public var hasReplicaID: Bool {return _storage._replicaID != nil}
  /// Clears the value of `replicaID`. Subsequent reads from it will return its default value.
  public mutating func clearReplicaID() {_uniqueStorage()._replicaID = nil}

  /// Not a map since we cannot use `replicaId` as key
  public var state: [ProtoCRDTGCounter.ReplicaState] {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  public var delta: ProtoCRDTGCounter.Delta {
    get {return _storage._delta ?? ProtoCRDTGCounter.Delta()}
    set {_uniqueStorage()._delta = newValue}
  }
  /// Returns true if `delta` has been explicitly set.
  public var hasDelta: Bool {return _storage._delta != nil}
  /// Clears the value of `delta`. Subsequent reads from it will return its default value.
  public mutating func clearDelta() {_uniqueStorage()._delta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ReplicaState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var replicaID: ProtoVersionReplicaID {
      get {return _storage._replicaID ?? ProtoVersionReplicaID()}
      set {_uniqueStorage()._replicaID = newValue}
    }
    /// Returns true if `replicaID` has been explicitly set.
    public var hasReplicaID: Bool {return _storage._replicaID != nil}
    /// Clears the value of `replicaID`. Subsequent reads from it will return its default value.
    public mutating func clearReplicaID() {_uniqueStorage()._replicaID = nil}

    public var count: UInt64 {
      get {return _storage._count}
      set {_uniqueStorage()._count = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct Delta {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var state: [ProtoCRDTGCounter.ReplicaState] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ProtoCRDTORSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var replicaID: ProtoVersionReplicaID {
    get {return _storage._replicaID ?? ProtoVersionReplicaID()}
    set {_uniqueStorage()._replicaID = newValue}
  }
  /// Returns true if `replicaID` has been explicitly set.
  public var hasReplicaID: Bool {return _storage._replicaID != nil}
  /// Clears the value of `replicaID`. Subsequent reads from it will return its default value.
  public mutating func clearReplicaID() {_uniqueStorage()._replicaID = nil}

  /// Includes delta
  public var state: ProtoCRDTVersionedContainer {
    get {return _storage._state ?? ProtoCRDTVersionedContainer()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ProtoCRDTORMapKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var manifest: ProtoManifest {
    get {return _storage._manifest ?? ProtoManifest()}
    set {_uniqueStorage()._manifest = newValue}
  }
  /// Returns true if `manifest` has been explicitly set.
  public var hasManifest: Bool {return _storage._manifest != nil}
  /// Clears the value of `manifest`. Subsequent reads from it will return its default value.
  public mutating func clearManifest() {_uniqueStorage()._manifest = nil}

  public var payload: Data {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ProtoCRDTORMapValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var manifest: ProtoManifest {
    get {return _storage._manifest ?? ProtoManifest()}
    set {_uniqueStorage()._manifest = newValue}
  }
  /// Returns true if `manifest` has been explicitly set.
  public var hasManifest: Bool {return _storage._manifest != nil}
  /// Clears the value of `manifest`. Subsequent reads from it will return its default value.
  public mutating func clearManifest() {_uniqueStorage()._manifest = nil}

  public var payload: Data {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ProtoCRDTORMapKeyValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: ProtoCRDTORMapKey {
    get {return _storage._key ?? ProtoCRDTORMapKey()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_uniqueStorage()._key = nil}

  public var value: ProtoCRDTORMapValue {
    get {return _storage._value ?? ProtoCRDTORMapValue()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ProtoCRDTORMap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var replicaID: ProtoVersionReplicaID {
    get {return _storage._replicaID ?? ProtoVersionReplicaID()}
    set {_uniqueStorage()._replicaID = newValue}
  }
  /// Returns true if `replicaID` has been explicitly set.
  public var hasReplicaID: Bool {return _storage._replicaID != nil}
  /// Clears the value of `replicaID`. Subsequent reads from it will return its default value.
  public mutating func clearReplicaID() {_uniqueStorage()._replicaID = nil}

  public var keys: ProtoCRDTORSet {
    get {return _storage._keys ?? ProtoCRDTORSet()}
    set {_uniqueStorage()._keys = newValue}
  }
  /// Returns true if `keys` has been explicitly set.
  public var hasKeys: Bool {return _storage._keys != nil}
  /// Clears the value of `keys`. Subsequent reads from it will return its default value.
  public mutating func clearKeys() {_uniqueStorage()._keys = nil}

  public var values: [ProtoCRDTORMapKeyValue] {
    get {return _storage._values}
    set {_uniqueStorage()._values = newValue}
  }

  /// Delta is derived from `updatedValues`
  public var updatedValues: [ProtoCRDTORMapKeyValue] {
    get {return _storage._updatedValues}
    set {_uniqueStorage()._updatedValues = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Delta {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var keys: ProtoCRDTVersionedContainerDelta {
      get {return _storage._keys ?? ProtoCRDTVersionedContainerDelta()}
      set {_uniqueStorage()._keys = newValue}
    }
    /// Returns true if `keys` has been explicitly set.
    public var hasKeys: Bool {return _storage._keys != nil}
    /// Clears the value of `keys`. Subsequent reads from it will return its default value.
    public mutating func clearKeys() {_uniqueStorage()._keys = nil}

    public var values: [ProtoCRDTORMapKeyValue] {
      get {return _storage._values}
      set {_uniqueStorage()._values = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ProtoCRDTLWWRegister {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var replicaID: ProtoVersionReplicaID {
    get {return _storage._replicaID ?? ProtoVersionReplicaID()}
    set {_uniqueStorage()._replicaID = newValue}
  }
  /// Returns true if `replicaID` has been explicitly set.
  public var hasReplicaID: Bool {return _storage._replicaID != nil}
  /// Clears the value of `replicaID`. Subsequent reads from it will return its default value.
  public mutating func clearReplicaID() {_uniqueStorage()._replicaID = nil}

  public var initialValue: ProtoCRDTLWWRegister.Value {
    get {return _storage._initialValue ?? ProtoCRDTLWWRegister.Value()}
    set {_uniqueStorage()._initialValue = newValue}
  }
  /// Returns true if `initialValue` has been explicitly set.
  public var hasInitialValue: Bool {return _storage._initialValue != nil}
  /// Clears the value of `initialValue`. Subsequent reads from it will return its default value.
  public mutating func clearInitialValue() {_uniqueStorage()._initialValue = nil}

  public var value: ProtoCRDTLWWRegister.Value {
    get {return _storage._value ?? ProtoCRDTLWWRegister.Value()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  public var clock: ProtoCRDTLWWRegister.Clock {
    get {return _storage._clock ?? ProtoCRDTLWWRegister.Clock()}
    set {_uniqueStorage()._clock = newValue}
  }
  /// Returns true if `clock` has been explicitly set.
  public var hasClock: Bool {return _storage._clock != nil}
  /// Clears the value of `clock`. Subsequent reads from it will return its default value.
  public mutating func clearClock() {_uniqueStorage()._clock = nil}

  public var updatedBy: ProtoVersionReplicaID {
    get {return _storage._updatedBy ?? ProtoVersionReplicaID()}
    set {_uniqueStorage()._updatedBy = newValue}
  }
  /// Returns true if `updatedBy` has been explicitly set.
  public var hasUpdatedBy: Bool {return _storage._updatedBy != nil}
  /// Clears the value of `updatedBy`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedBy() {_uniqueStorage()._updatedBy = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Value {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var manifest: ProtoManifest {
      get {return _storage._manifest ?? ProtoManifest()}
      set {_uniqueStorage()._manifest = newValue}
    }
    /// Returns true if `manifest` has been explicitly set.
    public var hasManifest: Bool {return _storage._manifest != nil}
    /// Clears the value of `manifest`. Subsequent reads from it will return its default value.
    public mutating func clearManifest() {_uniqueStorage()._manifest = nil}

    public var payload: Data {
      get {return _storage._payload}
      set {_uniqueStorage()._payload = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct Clock {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var manifest: ProtoManifest {
      get {return _storage._manifest ?? ProtoManifest()}
      set {_uniqueStorage()._manifest = newValue}
    }
    /// Returns true if `manifest` has been explicitly set.
    public var hasManifest: Bool {return _storage._manifest != nil}
    /// Clears the value of `manifest`. Subsequent reads from it will return its default value.
    public mutating func clearManifest() {_uniqueStorage()._manifest = nil}

    public var payload: Data {
      get {return _storage._payload}
      set {_uniqueStorage()._payload = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ProtoCRDTIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CRDTIdentity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtoCRDTIdentity, rhs: ProtoCRDTIdentity) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoCRDTVersionContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CRDTVersionContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "versionVector"),
    2: .same(proto: "gaps"),
  ]

  fileprivate class _StorageClass {
    var _versionVector: ProtoVersionVector? = nil
    var _gaps: [ProtoVersionDot] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _versionVector = source._versionVector
      _gaps = source._gaps
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._versionVector)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._gaps)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._versionVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._gaps.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._gaps, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtoCRDTVersionContext, rhs: ProtoCRDTVersionContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._versionVector != rhs_storage._versionVector {return false}
        if _storage._gaps != rhs_storage._gaps {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoCRDTVersionedContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CRDTVersionedContainer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replicaID"),
    2: .same(proto: "versionContext"),
    3: .same(proto: "elementByBirthDot"),
    4: .same(proto: "delta"),
  ]

  fileprivate class _StorageClass {
    var _replicaID: ProtoVersionReplicaID? = nil
    var _versionContext: ProtoCRDTVersionContext? = nil
    var _elementByBirthDot: [ProtoVersionDottedElementEnvelope] = []
    var _delta: ProtoCRDTVersionedContainerDelta? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _replicaID = source._replicaID
      _versionContext = source._versionContext
      _elementByBirthDot = source._elementByBirthDot
      _delta = source._delta
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._replicaID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._versionContext)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._elementByBirthDot)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._delta)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._replicaID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._versionContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._elementByBirthDot.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._elementByBirthDot, fieldNumber: 3)
      }
      if let v = _storage._delta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtoCRDTVersionedContainer, rhs: ProtoCRDTVersionedContainer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._replicaID != rhs_storage._replicaID {return false}
        if _storage._versionContext != rhs_storage._versionContext {return false}
        if _storage._elementByBirthDot != rhs_storage._elementByBirthDot {return false}
        if _storage._delta != rhs_storage._delta {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoCRDTVersionedContainerDelta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CRDTVersionedContainerDelta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "versionContext"),
    2: .same(proto: "elementByBirthDot"),
  ]

  fileprivate class _StorageClass {
    var _versionContext: ProtoCRDTVersionContext? = nil
    var _elementByBirthDot: [ProtoVersionDottedElementEnvelope] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _versionContext = source._versionContext
      _elementByBirthDot = source._elementByBirthDot
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._versionContext)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._elementByBirthDot)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._versionContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._elementByBirthDot.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._elementByBirthDot, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtoCRDTVersionedContainerDelta, rhs: ProtoCRDTVersionedContainerDelta) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._versionContext != rhs_storage._versionContext {return false}
        if _storage._elementByBirthDot != rhs_storage._elementByBirthDot {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoCRDTGCounter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CRDTGCounter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replicaID"),
    2: .same(proto: "state"),
    3: .same(proto: "delta"),
  ]

  fileprivate class _StorageClass {
    var _replicaID: ProtoVersionReplicaID? = nil
    var _state: [ProtoCRDTGCounter.ReplicaState] = []
    var _delta: ProtoCRDTGCounter.Delta? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _replicaID = source._replicaID
      _state = source._state
      _delta = source._delta
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._replicaID)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._state)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._delta)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._replicaID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._state.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._state, fieldNumber: 2)
      }
      if let v = _storage._delta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtoCRDTGCounter, rhs: ProtoCRDTGCounter) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._replicaID != rhs_storage._replicaID {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._delta != rhs_storage._delta {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoCRDTGCounter.ReplicaState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProtoCRDTGCounter.protoMessageName + ".ReplicaState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replicaId"),
    2: .same(proto: "count"),
  ]

  fileprivate class _StorageClass {
    var _replicaID: ProtoVersionReplicaID? = nil
    var _count: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _replicaID = source._replicaID
      _count = source._count
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._replicaID)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._count)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._replicaID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._count != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._count, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtoCRDTGCounter.ReplicaState, rhs: ProtoCRDTGCounter.ReplicaState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._replicaID != rhs_storage._replicaID {return false}
        if _storage._count != rhs_storage._count {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoCRDTGCounter.Delta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProtoCRDTGCounter.protoMessageName + ".Delta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.state)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.state.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtoCRDTGCounter.Delta, rhs: ProtoCRDTGCounter.Delta) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoCRDTORSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CRDTORSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replicaID"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _replicaID: ProtoVersionReplicaID? = nil
    var _state: ProtoCRDTVersionedContainer? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _replicaID = source._replicaID
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._replicaID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._replicaID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtoCRDTORSet, rhs: ProtoCRDTORSet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._replicaID != rhs_storage._replicaID {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoCRDTORMapKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CRDTORMapKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "manifest"),
    2: .same(proto: "payload"),
  ]

  fileprivate class _StorageClass {
    var _manifest: ProtoManifest? = nil
    var _payload: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _manifest = source._manifest
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._manifest)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._payload)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._manifest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._payload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._payload, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtoCRDTORMapKey, rhs: ProtoCRDTORMapKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._manifest != rhs_storage._manifest {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoCRDTORMapValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CRDTORMapValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "manifest"),
    2: .same(proto: "payload"),
  ]

  fileprivate class _StorageClass {
    var _manifest: ProtoManifest? = nil
    var _payload: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _manifest = source._manifest
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._manifest)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._payload)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._manifest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._payload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._payload, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtoCRDTORMapValue, rhs: ProtoCRDTORMapValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._manifest != rhs_storage._manifest {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoCRDTORMapKeyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CRDTORMapKeyValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  fileprivate class _StorageClass {
    var _key: ProtoCRDTORMapKey? = nil
    var _value: ProtoCRDTORMapValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._key)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._value)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtoCRDTORMapKeyValue, rhs: ProtoCRDTORMapKeyValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoCRDTORMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CRDTORMap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replicaID"),
    2: .same(proto: "keys"),
    3: .same(proto: "values"),
    4: .same(proto: "updatedValues"),
  ]

  fileprivate class _StorageClass {
    var _replicaID: ProtoVersionReplicaID? = nil
    var _keys: ProtoCRDTORSet? = nil
    var _values: [ProtoCRDTORMapKeyValue] = []
    var _updatedValues: [ProtoCRDTORMapKeyValue] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _replicaID = source._replicaID
      _keys = source._keys
      _values = source._values
      _updatedValues = source._updatedValues
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._replicaID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._keys)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._values)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._updatedValues)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._replicaID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._keys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._values.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._values, fieldNumber: 3)
      }
      if !_storage._updatedValues.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._updatedValues, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtoCRDTORMap, rhs: ProtoCRDTORMap) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._replicaID != rhs_storage._replicaID {return false}
        if _storage._keys != rhs_storage._keys {return false}
        if _storage._values != rhs_storage._values {return false}
        if _storage._updatedValues != rhs_storage._updatedValues {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoCRDTORMap.Delta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProtoCRDTORMap.protoMessageName + ".Delta"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
    2: .same(proto: "values"),
  ]

  fileprivate class _StorageClass {
    var _keys: ProtoCRDTVersionedContainerDelta? = nil
    var _values: [ProtoCRDTORMapKeyValue] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _keys = source._keys
      _values = source._values
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._keys)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._values)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._keys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._values.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._values, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtoCRDTORMap.Delta, rhs: ProtoCRDTORMap.Delta) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._keys != rhs_storage._keys {return false}
        if _storage._values != rhs_storage._values {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoCRDTLWWRegister: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CRDTLWWRegister"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "replicaID"),
    2: .same(proto: "initialValue"),
    3: .same(proto: "value"),
    4: .same(proto: "clock"),
    5: .same(proto: "updatedBy"),
  ]

  fileprivate class _StorageClass {
    var _replicaID: ProtoVersionReplicaID? = nil
    var _initialValue: ProtoCRDTLWWRegister.Value? = nil
    var _value: ProtoCRDTLWWRegister.Value? = nil
    var _clock: ProtoCRDTLWWRegister.Clock? = nil
    var _updatedBy: ProtoVersionReplicaID? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _replicaID = source._replicaID
      _initialValue = source._initialValue
      _value = source._value
      _clock = source._clock
      _updatedBy = source._updatedBy
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._replicaID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._initialValue)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._value)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._clock)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._updatedBy)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._replicaID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._initialValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._clock {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._updatedBy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtoCRDTLWWRegister, rhs: ProtoCRDTLWWRegister) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._replicaID != rhs_storage._replicaID {return false}
        if _storage._initialValue != rhs_storage._initialValue {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._clock != rhs_storage._clock {return false}
        if _storage._updatedBy != rhs_storage._updatedBy {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoCRDTLWWRegister.Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProtoCRDTLWWRegister.protoMessageName + ".Value"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "manifest"),
    2: .same(proto: "payload"),
  ]

  fileprivate class _StorageClass {
    var _manifest: ProtoManifest? = nil
    var _payload: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _manifest = source._manifest
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._manifest)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._payload)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._manifest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._payload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._payload, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtoCRDTLWWRegister.Value, rhs: ProtoCRDTLWWRegister.Value) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._manifest != rhs_storage._manifest {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoCRDTLWWRegister.Clock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProtoCRDTLWWRegister.protoMessageName + ".Clock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "manifest"),
    2: .same(proto: "payload"),
  ]

  fileprivate class _StorageClass {
    var _manifest: ProtoManifest? = nil
    var _payload: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _manifest = source._manifest
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._manifest)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._payload)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._manifest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._payload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._payload, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtoCRDTLWWRegister.Clock, rhs: ProtoCRDTLWWRegister.Clock) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._manifest != rhs_storage._manifest {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
