//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Distributed Actors open source project
//
// Copyright (c) 2019 Apple Inc. and the Swift Distributed Actors project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.md for the list of Swift Distributed Actors project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import DistributedActors
import Stencil
import SwiftSyntax

protocol Renderable {
    func render(_ settings: GenerateActors.Settings) throws -> String
}

enum Rendering {
    static let generatedFileHeader: String =
        """
        // ==== ------------------------------------------------------------------ ====
        // === DO NOT EDIT: Generated by GenActors                     
        // ==== ------------------------------------------------------------------ ====

        """
}

extension Rendering {
    struct ActorShellTemplate: Renderable {
        let actorable: ActorableTypeDecl

        static let messageForNonProtocolTemplate = Template(
            templateString:
            """
            // ==== ----------------------------------------------------------------------------------------------------------------
            // MARK: DO NOT EDIT: Generated {{baseName}} messages 

            /// DO NOT EDIT: Generated {{baseName}} messages
            extension {{baseName}} {

                {{messageAccess}} enum Message { {% for case in funcCases %}
                    {{case}} {% endfor %}
                }
                {%for tell in boxFuncs %}
                {{ tell }} 
                {% endfor %}
            }
            """
        )

        static let messageForProtocolTemplate = Template(
            templateString:
            """
            // ==== ----------------------------------------------------------------------------------------------------------------
            // MARK: DO NOT EDIT: Generated {{baseName}} messages 

            extension GeneratedActor.Messages {
                {{messageAccess}} enum {{baseName}} { {% for case in funcCases %}
                    {{case}} {% endfor %} 
                }
            }

            """
        )

        static let boxingForProtocolTemplate = Template(
            templateString:
            """
            // ==== ----------------------------------------------------------------------------------------------------------------
            // MARK: DO NOT EDIT: Boxing {{baseName}} for any inheriting actorable `A` 

            extension Actor where A: {{actorableProtocol}} {
            {%for tell in funcBoxTells %}
            {{ tell }} 
            {% endfor %}
            }

            """
        )

        static let behaviorTemplate = Template(
            templateString:
            """
            // ==== ----------------------------------------------------------------------------------------------------------------
            // MARK: DO NOT EDIT: Generated {{baseName}} behavior

            extension {{baseName}} {

                public static func makeBehavior(instance: {{baseName}}) -> Behavior<Message> {
                    return .setup { _context in
                        let context = Actor<{{baseName}}>.Context(underlying: _context)
                        {{varLetInstance}} instance = instance

                        /* await */ instance.preStart(context: context)

                        return Behavior<Message>.receiveMessage { message in
                            switch message { 
                            {% for case in funcSwitchCases %}
                            {{case}} {% endfor %}
                            {% for case in funcBoxSwitchCases %}
                            {{case}} {% endfor %}
                            }
                            return .same
                        }.receiveSignal { _context, signal in 
                            let context = Actor<{{baseName}}>.Context(underlying: _context)

                            switch signal {
                            case is Signals.PostStop: 
                                instance.postStop(context: context)
                                return .same
                            case let terminated as Signals.Terminated:
                                switch instance.receiveTerminated(context: context, terminated: terminated) {
                                case .unhandled: 
                                    return .unhandled
                                case .stop: 
                                    return .stop
                                case .ignore: 
                                    return .same
                                }
                            default:
                                return .unhandled
                            }
                        }
                    }
                }
            }

            """
        )

        static let actorTellTemplate = Template(
            templateString:
            """
            // ==== ----------------------------------------------------------------------------------------------------------------
            // MARK: Extend Actor for {{baseName}}

            extension Actor where A.Message == {{baseName}}.Message {
            {% for tell in funcTells %}
            {{ tell }} 
            {% endfor %}
            }

            """
        )

        func render(_ settings: GenerateActors.Settings) throws -> String {
            let context: [String: Any] = [
                "baseName": self.actorable.fullName,
                "actorableProtocol": self.actorable.type == .protocol ? self.actorable.name : "",

                "varLetInstance": self.actorable.renderStoreInstanceAs,

                "messageAccess": "public", // TODO: allow non public actor messages

                "funcCases": self.actorable.renderCaseDecls,

                "funcSwitchCases": try self.actorable.funcs.map {
                    try $0.renderFuncSwitchCase(partOfProtocol: nil)
                },
                "funcBoxSwitchCases": try self.actorable.actorableProtocols.flatMap { box in
                    try box.funcs.map {
                        try $0.renderFuncSwitchCase(partOfProtocol: box)
                    }
                },

                "boxFuncs": try self.actorable.actorableProtocols.map { inheritedProtocol in
                    try inheritedProtocol.renderBoxingFunc(in: self.actorable)
                },

                "funcTells": try self.actorable.funcs.map { funcDecl in
                    try CodePrinter.content { printer in
                        printer.indent()
                        try funcDecl.renderFuncTell(printer: &printer)
                    }
                },
                "funcBoxTells": self.actorable.type == .protocol ? try self.actorable.funcs.map { actorableFunc in
                    try CodePrinter.content { printer in
                        printer.indent()
                        try actorableFunc.renderBoxFuncTell(self.actorable, printer: &printer)
                    }
                } : [],
            ]

            var rendered: String = "\n"
            switch self.actorable.type {
            case .protocol:
                rendered.append(try Self.messageForProtocolTemplate.render(context))
            default:
                rendered.append(try Self.messageForNonProtocolTemplate.render(context))
                rendered.append("\n")
            }

            switch self.actorable.type {
            case .struct, .class, .enum, .extension:
                rendered.append(try Self.behaviorTemplate.render(context))
                rendered.append(try Self.actorTellTemplate.render(context))
            case .protocol:
                rendered.append(try Self.boxingForProtocolTemplate.render(context))
            }

            if settings.verbose {
                print(rendered)
            }

            return rendered
        }
    }
}

// ==== ----------------------------------------------------------------------------------------------------------------
// MARK: Rendering extensions

extension ActorableTypeDecl {
    /// Render if we should store this as `let` or `var`, as storing in the right way is important to avoid compiler warnings,
    /// i.e. we could store always in a var, but it'd cause warnings.
    var renderStoreInstanceAs: String {
        if self.type == DeclType.class {
            return "let"
        } else {
            // structs may need to be stored as var or let, depending if they have mutating members
            //
            // we need to also check all the adopted protocols if they cause any mutating calls;
            // TODO: this would need to go recursively all the way in reality; since protocols conform to other protocols etc.
            if self.funcs.contains(where: { $0.message.isMutating }) ||
                self.actorableProtocols.contains(where: { $0.funcs.contains(where: { $0.message.isMutating }) }) {
                return "var"
            } else {
                return "let"
            }
        }
    }

    var renderCaseLet: String {
        "case .\(self.nameFirstLowercased)(let boxed):"
    }

    var renderBoxCaseLet: String {
        "case .\(self.boxFuncName)(let boxed):"
    }

    var renderCaseDecls: [String] {
        let renderedDirectFuncs = self.funcs.map {
            $0.renderCaseDecl()
        }

        let renderedActorableProtocolBoxes = self.actorableProtocols.map { decl in
            "case \(decl.nameFirstLowercased)(/*TODO: MODULE.*/GeneratedActor.Messages.\(decl.name))"
        }

        var res: [String] = renderedDirectFuncs
        res.append(contentsOf: renderedActorableProtocolBoxes)

        return res
    }

    func renderBoxingFunc(in owner: ActorableTypeDecl) throws -> String {
        let context: [String: Any] = [
            "baseName": "\(owner.fullName)",
            "access": "public",
            "boxCaseName": "\(self.nameFirstLowercased)",
            "boxFuncName": "\(self.boxFuncName)",
            "messageToBoxType": "GeneratedActor.Messages.\(self.name)",
        ]

        return try Template(
            stringLiteral:
            """
            /// Performs boxing of {{messageToBoxType}} messages such that they can be received by Actor<{{baseName}}>
                {{access}} static func {{boxFuncName}}(_ message: {{messageToBoxType}}) -> {{baseName}}.Message {
                    .{{boxCaseName}}(message)
                }
            """
        ).render(context)
    }
}

extension ActorableMessageDecl {
    var returnIfBecome: String {
        switch self.returnType {
        case .behavior:
            return "return /*become*/ "
        default:
            return ""
        }
    }

    var renderCaseDecl: String {
        guard !self.effectiveParams.isEmpty else {
            return "case \(self.name)"
        }

        var ret = "case \(self.name)("
        ret.append(
            self.effectiveParams.map { first, second, tpe in
                // FIXME: super naive... replace with something more proper
                let type = tpe
                    .replacingOccurrences(of: "<Self>", with: "<\(self.actorableName)>")
                    .replacingOccurrences(of: "<Self,", with: "<\(self.actorableName),")
                    .replacingOccurrences(of: ",Self>", with: ",\(self.actorableName)>")
                    .replacingOccurrences(of: ", Self>", with: ", \(self.actorableName)>")

                if let name = first, name == "_" {
                    return "\(type)"
                } else if let name = first {
                    return "\(name): \(type)"
                } else {
                    return "\(second): \(type)"
                }
            }.joined(separator: ", ")
        )
        ret.append(")")

        return ret
    }

    func renderFunc(printer: inout CodePrinter, printBody: (inout CodePrinter) -> Void) {
        self.renderFuncDecl(printer: &printer)
        printer.print(" {")
        printer.indent()
        printBody(&printer)
        printer.outdent()
        printer.print("}")
    }

    func renderFuncDecl(printer: inout CodePrinter) {
        let access = self.access.map {
            "\($0) "
        } ?? ""

        printer.print("\(access)func \(self.name)(\(self.renderFuncParams))\(self.returnType.renderReturnTypeDeclPart)", skipNewline: true)
    }

    var renderFuncParams: String {
        self.params.map { first, second, tpe in
            // FIXME: super naive... replace with something more proper
            let type = tpe
                .replacingOccurrences(of: "<Self>", with: "<\(self.actorableName)>")
                .replacingOccurrences(of: "<Self,", with: "<\(self.actorableName),")
                .replacingOccurrences(of: ",Self>", with: ",\(self.actorableName)>")
                .replacingOccurrences(of: ", Self>", with: ", \(self.actorableName)>")

            if let name = first {
                if name == second {
                    // no need to write `name name: String`
                    return "\(name): \(type)"
                }
                return "\(name) \(second): \(type)"
            } else {
                return "\(second): \(type)"
            }
        }.joined(separator: ", ")
    }

    /// Renders:
    ///
    /// ````(let thing, let other)
    var renderCaseLetParams: String {
        if self.effectiveParams.isEmpty {
            return ""
        } else {
            return "(" +
                self.effectiveParams.map { _, secondName, _ in
                    // TODO: Finally change the triple tuple into a specific type with more helpers
                    let name: String
//                    if firstName == "_" {
//                        name = secondName
//                    } else {
//                        name = firstName ?? secondName
//                    }
                    name = secondName
                    return "let \(name)"
                }.joined(separator: ", ") +
                ")"
        }
    }

    // // nothing
    // (hello: hello)
    // (_replyTo: _replyTo)
    var passEffectiveParamsWithBraces: String {
        if self.effectiveParams.isEmpty {
            return self.renderPassParams(effectiveParamsToo: true)
        } else {
            return "(\(self.renderPassParams(effectiveParamsToo: true)))"
        }
    }

    // WARNING: Does not wrap with `()`
    //
    // // nothing
    // hello: hello
    // hello: hello, two: two
    var passParams: String {
        self.renderPassParams(effectiveParamsToo: false)
    }

    func renderPassParams(effectiveParamsToo: Bool) -> String {
        let ps = effectiveParamsToo ? self.effectiveParams : self.params
        if ps.isEmpty {
            return ""
        } else {
            return ps.map { p in
                if let name = p.0, name == "_" {
                    // greet(name)
                    return "\(p.1)"
                } else {
                    // greet(name: name)
                    return "\(p.0 ?? p.1): \(p.1)"
                }
            }.joined(separator: ", ")
        }
    }

    /// Implements the generated func method(...) by passing the parameters as a message, by telling or asking.
    func renderTellOrAskMessage(boxWith boxProtocol: ActorableTypeDecl? = nil, printer: inout CodePrinter) {
        var isAsk = false

        switch self.returnType {
        case .nioEventLoopFuture(let futureValueType):
            isAsk = true
            printer.print("// TODO: FIXME perhaps timeout should be taken from context")
            printer.print("Reply(nioFuture:")
            printer.indent()
            printer.print("self.ref.ask(for: Result<\(futureValueType), Error>.self, timeout: .effectivelyInfinite) { _replyTo in")
            printer.indent()
        case .type(let t):
            isAsk = true
            printer.print("// TODO: FIXME perhaps timeout should be taken from context")
            printer.print("Reply(nioFuture:")
            printer.indent()
            if self.throwing {
                printer.print("self.ref.ask(for: Result<\(t), Error>.self, timeout: .effectivelyInfinite) { _replyTo in")
                printer.indent()
            } else {
                printer.print("self.ref.ask(for: \(t).self, timeout: .effectivelyInfinite) { _replyTo in")
                printer.indent()
            }
        case .result(let t, let errType):
            isAsk = true
            printer.print("// TODO: FIXME perhaps timeout should be taken from context")
            printer.print("Reply(nioFuture:")
            printer.indent()
            printer.print("self.ref.ask(for: Result<\(t), \(errType)>.self, timeout: .effectivelyInfinite) { _replyTo in")
            printer.indent()
        case .void:
            printer.print("self.ref.tell(", skipNewline: true)
        case .behavior:
            printer.print("self.ref.tell(", skipNewline: true)
        }

        self.renderPassMessage(boxWith: boxProtocol, printer: &printer)

        if isAsk {
            printer.print("\n")
            printer.print("}")
            printer.outdent()
            if self.throwing || self.returnType.isFutureReturn {
                printer.print(".nioFuture.flatMapThrowing { result in")
                printer.indent()
                printer.print("switch result {")
                printer.print("case .success(let res): return res")
                printer.print("case .failure(let err): throw err")
                printer.print("}")
                printer.outdent()
                printer.print("}")
            } else {
                printer.print(".nioFuture")
            }
            printer.print(")")
            printer.outdent()
        } else {
            printer.print(")")
        }
    }

    func renderPassMessage(boxWith boxProtocol: ActorableTypeDecl?, printer: inout CodePrinter) {
        if let boxName = boxProtocol?.boxFuncName {
            printer.print("A.", skipNewline: true)
            printer.print(boxName, skipNewline: true)
            printer.print("(", skipNewline: true)
        }
        printer.print(".\(self.name)", skipNewline: true)

        printer.print(self.passEffectiveParamsWithBraces, skipNewline: true)

        if boxProtocol != nil {
            printer.print(")", skipNewline: true)
        }
    }
}

extension ActorableMessageDecl.ReturnType {
    /// Renders:
    /// ```
    ///
    /// // or
    /// -> Reply<T>
    /// ```
    var renderReturnTypeDeclPart: String {
        switch self {
        case .void:
            return ""
        case .behavior:
            return ""
        case .result(let t, let errT):
            return " -> ResultReply<\(t), \(errT)>" // TODO: Reply type; ResultReply<T, Reason>
        case .nioEventLoopFuture(let t):
            return " -> Reply<\(t)>" // TODO: Reply type; Reply<T>
        case .type(let t):
            return " -> Reply<\(t)>" // TODO: Reply type; Reply<T>
        }
    }

    var isTypeReturn: Bool {
        if case .type = self {
            return true
        } else {
            return false
        }
    }

    var isFutureReturn: Bool {
        if case .nioEventLoopFuture = self {
            return true
        } else {
            return false
        }
    }

    var rendersReturn: Bool {
        switch self {
        case .void, .behavior:
            return false
        case .type, .result, .nioEventLoopFuture:
            return true
        }
    }
}

extension ActorFuncDecl {
    func renderFuncTell(printer: inout CodePrinter) throws {
        self.message.renderFunc(printer: &printer) { printer in
            message.renderTellOrAskMessage(boxWith: nil, printer: &printer)
        }
    }

    func renderBoxFuncTell(_ actorableProtocol: ActorableTypeDecl, printer: inout CodePrinter) throws {
        precondition(actorableProtocol.type == .protocol, "protocolToBox MUST be protocol, was: \(actorableProtocol)")

        self.message.renderFunc(printer: &printer) { printer in
            self.message.renderTellOrAskMessage(boxWith: actorableProtocol, printer: &printer)
        }
    }

    // TODO: dedup with the boxed one
    func renderFuncSwitchCase(partOfProtocol ownerProtocol: ActorableTypeDecl?) throws -> String {
        var ret = "case "

        if let boxProto = ownerProtocol {
            ret.append(".")
            ret.append(boxProto.nameFirstLowercased)
            ret.append("(")
        }
        ret.append(".\(message.name)\(message.renderCaseLetParams)")
        if ownerProtocol != nil {
            ret.append(")")
        }
        ret.append(":\n")

        let context: [String: Any] = [
            "name": self.message.name,
            "returnIfBecome": self.message.returnIfBecome,
            "storeIfTypeReturn": self.message.returnType.isTypeReturn ? "let result = " : "",
            "replyWithTypeReturn": self.message.returnType.isTypeReturn ?
                (self.message.throwing ?
                    "\n                    _replyTo.tell(.success(result))" :
                    "\n                    _replyTo.tell(result)"
                ) : "",
            "try": self.message.throwing ? "try " : "",
            "passParams": self.message.passParams,
        ]

        if self.message.throwing, self.message.returnType.rendersReturn {
            ret.append("                    do {")
            ret.append("\n")
        }

        // FIXME: it really is time to adopt CodePrinter

        // render invocation
        ret.append(try Template(
            templateString:
            "                    {{storeIfTypeReturn}}{{returnIfBecome}}{{try}}instance.{{name}}({{passParams}}){{replyWithTypeReturn}}"
        ).render(context))

        if case .nioEventLoopFuture = self.message.returnType {
            ret.append("\n                                    .whenComplete { res in _replyTo.tell(res) }")
        } else {
            ret.append("\n")
        }

        if self.message.throwing, self.message.returnType.rendersReturn {
            let pad = "                    " // FIXME: replace with code printer
            ret.append("\(pad)} catch {\n")
            ret.append("\(pad)    context.log.warning(\"Error thrown while handling [\\(message)], error: \\(error)\")\n")
            ret.append("\(pad)    _replyTo.tell(.failure(error))\n")
            ret.append("\(pad)}\n")
        }

        return ret
    }

    func renderCaseDecl() -> String {
        self.message.renderCaseDecl
    }
}
