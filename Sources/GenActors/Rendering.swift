//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Distributed Actors open source project
//
// Copyright (c) 2019 Apple Inc. and the Swift Distributed Actors project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.md for the list of Swift Distributed Actors project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import DistributedActors
import Stencil

protocol Renderable {
    func render() throws -> String
}

enum Rendering {
    static let generatedFileHeader: String =
        """
        // ==== ------------------------------------------------------------------ ====
        // === DO NOT EDIT: Generated by GenActors                     
        // ==== ------------------------------------------------------------------ ====

        import DistributedActors

        """

    struct ActorShellTemplate: Renderable {
        let baseName: String
        let funcs: [ActorFunc]

        static let template = Template(
            templateString:
            """

            // ==== ----------------------------------------------------------------------------------------------------------------
            // MARK: DO NOT EDIT: Generated {{baseName}} messages 

            extension {{baseName}} {
                {{messageAccess}} enum Message { {% for case in funcCases %}
                    {{case}} {% endfor %} 
                }
            }

            // ==== ----------------------------------------------------------------------------------------------------------------
            // MARK: DO NOT EDIT: Generated {{baseName}} behavior

            extension {{baseName}} {
                 public static func makeBehavior(instance: {{baseName}}) -> Behavior<Message> {
                    return .setup { context in
                        var instance = instance // TODO only var if any of the methods are mutating

                        // /* await */ self.instance.preStart(context: context) // TODO: enable preStart

                        return .receiveMessage { message in
                            switch message { 
                            {% for case in funcSwitchCases %}
                            {{case}} {% endfor %}
                            }
                            return .same
                        }
                    }
                }

            }

            // ==== ----------------------------------------------------------------------------------------------------------------
            // MARK: Extend Actor for {{baseName}}

            extension Actor where A.Message == {{baseName}}.Message {
                {% for tell in funcTells %}
                {{ tell }} 
                {% endfor %}
            }

            """
        )

        func render() throws -> String {
            precondition(self.baseName != "", "baseName was empty!")
            let context: [String: Any] = [
                "baseName": self.baseName,
                "messageAccess": "public", // TODO: allow non public actor messages
                "funcCases": self.funcs.map {
                    $0.renderCaseDecl()
                },
                "funcTells": try self.funcs.map {
                    try $0.renderFuncTell()
                },
                "funcSwitchCases": try self.funcs.map {
                    try $0.renderFuncSwitchCase()
                },
            ]

            let rendered = try ActorShellTemplate.template.render(context)
            print(rendered)

            return rendered
        }
    }
}

// ==== ----------------------------------------------------------------------------------------------------------------
// MARK: Rendering models

struct ActorableMessageDecl {
    let access: String?
    let name: String

    typealias Name = String
    typealias TypeName = String
    let params: [(Name?, Name, TypeName)]

    var caseDecl: String {
        guard !self.params.isEmpty else {
            return "case \(self.name)"
        }

        var ret = "case \(self.name)("
        ret.append(
            self.params.map { first, second, type in
                if let name = first, name == "_" {
                    return "\(type)"
                } else if let name = first {
                    return "\(name): \(type)"
                } else {
                    return "\(second): \(type)"
                }
            }.joined(separator: ", ")
        )
        ret.append(")")

        return ret
    }

    var funcDecl: String {
        let access = self.access.map {
            "\($0) "
        } ?? ""

        return "\(access)func \(self.name)(\(self.funcParams))"
    }

    var funcParams: String {
        return self.params.map { first, second, type in
            if let name = first {
                if name == second {
                    // no need to write `name name: String`
                    return "\(name): \(type)"
                }
                return "\(name) \(second): \(type)"
            } else {
                return "\(second): \(type)"
            }
        }.joined(separator: ", ")
    }

    var caseLetParams: String {
        if self.params.isEmpty {
            return ""
        } else {
            return "(" +
                self.params.map { p in
                    "let \(p.1)"
                }.joined(separator: ", ") +
                ")"
        }
    }

    var passParams: String {
        if self.params.isEmpty {
            return ""
        } else {
            return self.params.map { p in
                if let name = p.0, name == "_" {
                    // greet(name)
                    return "\(p.1)"
                } else {
                    // greet(name: name)
                    return "\(p.1): \(p.1)"
                }
            }.joined(separator: ", ")
        }
    }

    var passMessage: String {
        var ret = ".\(self.name)"

        if !self.params.isEmpty {
            ret.append("(")
            ret.append(self.passParams)
            ret.append(")")
        }

        return ret
    }
}

struct ActorFunc {
    let message: ActorableMessageDecl

    func renderFuncTell() throws -> String {
        let context: [String: Any] = [
            "funcDecl": message.funcDecl,
            "passMessage": message.passMessage,
        ]

        let rendered = try Template(
            templateString:
            """
            {{funcDecl}} { // TODO: returning things
                    self.ref.tell({{passMessage}})
                }
            """
        ).render(context)

        return rendered
    }

    func renderFuncSwitchCase() throws -> String {
        let context: [String: Any] = [
            "name": message.name,
            "caseLetParams": message.caseLetParams,
            "passParams": message.passParams,
        ]

        let rendered = try Template(
            templateString:
            """
            case .{{name}}{{caseLetParams}}:
                                instance.{{name}}({{passParams}})
            """
        ).render(context)

        return rendered
    }

    func renderCaseDecl() -> String {
        return self.message.caseDecl
    }
}
