== Fault handling

General description

=== Vocabulary

Since there are various "types" of failures conditions, Swift Distributed Actors defines the following vocabulary in order to make discussing
failure handling scenarios harder to misunderstand:

- *Failure* - the most general term for any kind of "faulty" behavior, including: errors, throws, crashes, fatal errors,
- *Error* as in "throw an error" - the classic meaning of "error" in Swift, which is bound to the `Error` type,
  and means any operation that can throw an error.
- *Fault* as in "faulty operation"

You may wonder how the various other words used by the underlying OS relate to them.
For example, in POSIX systems faults are signalled by "error codes" and "signals".
Some of such conditions are recoverable _within an actor_ and Swift Distributed Actors allows doing so,
however code execution beyond a faulty line of code is never allowed.

Summing up, any Error or Fault is a type of Failure in Swift Distributed Actors wording. We hope that this wording remains consistent
enough with the rest of the ecosystem.

Further, you can expect to hear the following phrases:

- "the actor has thrown", "an error during message processing" - an error was thrown during message or signal processing
- "the actor crashed" - meaning that the actor was stopped in response to a failure

== Supervision

Actor supervision in Swift Distributed Actors is a core concept that allows for building resilient concurrent and distributed actor systems.

NOTE: Supervision is a concept core to most, if not all, actor implementations.
      The most notable implementations heavily relying on supervision concepts are Erlang/OTP, Akka.
      While the core ideas and mechanisms are very similar in Swift Distributed Actors, be aware that each runtime has its own specific
      challenges and as such may differ slightly in wording or implementation.


Supervision in Swift Distributed Actors is offered to users via Behavior decorators, that are recognized and executed by the actor system
when failures occur.


NOTE: It is NOT possible to supervise code running outside of actors.

NOTE: Implementation limitation: the current fault handling mechanisms rely on signal handlers, and as such may not mix
      well with other libraries which rely on this functionality. Our goal is to eventually solve this using a dedicated mechanism inside the runtime.

=== Supervision hierarchies

Swift Distributed Actors enforces a strict parent-child relationship between actors. Only an actor's parent actor MAY supervise it.
Other actors - be it siblings or other completely unrelated actors - may only _watch_ a given actor for termination.

This leads to the formation of so called supervision hierarchies or supervision "trees".
It also allows us to structure our applications in ways that represent their _fault domains_.

TODO: explain bulk heading and compartmentalization.

=== A word of caution: fatal faults

Swift Distributed Actors does NOT allow recovering from "fatal faults" such as segmentation faults (segfaults) or similar faults.
Some faults are serious enough that continuing running after they have occurred is too risky and should not be taken lightly.

At the same time, bear in mind that while it may be possible to recover from some faults using Swift Distributed Actors, it may not be the best course of action,
sometimes faults are legitimate problems and can leave your system vulnerable. Make sure to always investigate fault crashes
of your actors and aim to build systems where faults do not occur on regular basis.

=== Nested supervision

Since supervision is applied to behaviors by wrapping them using a supervision behavior,
it is possible to have multiple supervisors wrapping a behavior. When this happens, the order in which
supervisors will be notified about a fault is "from inner most, to outer most."

The assumption here is that
supervisors "closer to" the inner behavior are applied by code that is more aware of its internal workings, e.g.
a library author may know that the code may sometimes harmlessly fail due to some problem in the internally used library,
outside users of this behavior should not be exposed to the fact that this library is used by the actor, so it handles all
errors that this library may throw.

As users adopt this behavior, they may notice that sometimes a timeout error occurs and crashes the actor.
It MAY be fine to wrap this behavior in a backoff restarting supervisor to handle this timeout situation.


Examples:

    let providedByLibrary = internalBehavior.supervisedWith(strategy: restart ...)
    let prepped = providedByLibrary.supervisedWith(strategy: handleTimeouts)
    system.spawn(prepped, name: "worker")

=== Supervising specific Errors

It is also possible to constrain which type of failure a supervisor should supervise. For example, when working with APIs
that might throw errors when they are "overwhelmed" and our goal is simply to drop the message which caused this fault,
yet do not terminate the actor but continue processing other messages as they are independent requests, we might want to
supervise only for this `SomeLibraryOverloadedError`, yet leave all other errors to crash the actor and leave any compensating
actions to its parent.

// TODO snippets, explain that the match must be EXACT, we do not perform any "is subclass of" checks etc.
// TODO: We COULD, but then we have to make the Supervisor<Message, Error>

While this mechanism is useful, it should _not_ be used to replace traditional `do/catch` blocks which usually are much
better positioned to perform appropriate cleanup or compensating actions closer to the origin of the issue. For example
one might want to a connection or file before stopping the actor cleanly, or performing the cleanup and causing the actor
to crash by throwing a different Error which then can carry more contextual information about why this crash happened,
which can be useful in later diagnosis and fixing of the issue.

NOTE: Supervision is not intended to replace `do/catch` blocks, and should be used for "unexpected" failures.
      Try to use the "let it crash" philosophy when designing your actors and their interactions.
      Make sure that a crash would carry enough useful information to be able to attempt fixing it later on,
      e.g. by carrying trace or similar metadata which could help identify if it the error exists only for a specific
      entity or situation.


== Analysing Back Traces (Crash Logs)

When a fault occurs, Swift Distributed Actors will print a crash log. An excellent talk from WWDC 2018 titled
https://developer.apple.com/videos/play/wwdc2018/414/["Understanding Crashes and Crash Logs"] is available and explains
how to read and use crash logs (backtraces) to locate and isolate problems in your code.

Another useful resource to understand crash logs is https://developer.apple.com/library/archive/technotes/tn2151/_index.html[Understanding and Analyzing Application Crash Reports].
