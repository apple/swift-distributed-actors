
== Failure Handling

> Failures in distributed systems are common place, and one has to design such systems to be resilient to failures.
> Thankfully actors make this task much simpler, as all kinds of failures are unified into supervision or termination events,
> to which one can react to.

CAUTION: **The current supervision implementation** (of "faults" specifically) **is a Proof of Concept.** +
         +
         It "works, but..." will leak memory that the actor has allocated in case of
         supervision handling a fault (e.g. a division by zero). The application process will remain alive, the fault
         will be logged and handled by stopping or restarting the offending actor, however resources will leak. +
         +
         Supervision also handles `Error` throws which is safe in the same way throws in normal Swift applications are.

[[supervision_vocabulary]]
=== Failure Vocabulary

Before we explain the mechanisms available to you to handle failures in Swift Distributed Actors, we first need to define a shared vocabulary
that we will use while discussing these. Since there are various "types" of failure conditions, we want to be as specific
as possible when discussing them.

* *Error* as in "throw an error" - the classic meaning of "error" in Swift, which is bound to the `Error` type.
** Examples: any `Error` that is `throw`n from inside of a Swift function.
* *Fault* as in "faulty operation" - are most types of faults that Swift does not expose as Errors but would normally
  result in terminating the entire process.
** Examples: array-out-of-bounds access, forced `nil` unwrapping, division by zero, as well as calls to `fatalError`.
* *Failure* - is the term Swift Distributed Actors uses to classify either an Error or Fault, as supervision works for both classes of failures.
** Examples: either a Fault or an Error.

Summing up, any error or fault is a kind of failure.

TIP: This wording is also in alignment with Swift's own https://github.com/apple/swift/blob/master/stdlib/public/core/Result.swift[`Result`] type,
     where failed case is called `failure` and carries an `Error` instance.

Further more, you can expect see phases involving the word "crash". We use this word to mean a "stop" result of failure
handling or a failure causing the stopping of an entire node. The wording should usually classify what the subject of the
crash was, e.g. _"the system crashed"_ or _"the request handler (actor) crashed."_

=== Supervision

Actor supervision is a mechanism using which whoever is starting an actor (most often, its parent) can define
how the actor should handle failures if they occur.

Supervision is configured using api:Props[struct] (see <<props>>), and as such can only be configured when starting an actor.
Swift Distributed Actors provides a number of built in supervision strategies (api:SupervisionStrategy[enum]) which we'll explore in depth soon.

For now let's see how we could configure an actor to restart a few times, if it encountered a failure:

[source]
----
include::{dir_sact_doc_tests}/SupervisionDocExamples.swift[tag=supervise_props]
----
<1> TODO
<2> TODO

TIP: It is only possible to supervise code running "inside" of an actor. +
     If you schedule some asynchronous operation onto a different thread from within the actor,
     that failure is unlikely to return to the actor and make it fail. Be aware of this while integrating actors with other APIs.

WARNING: PoC Limitation: the current _fault_ handling mechanisms rely on POSIX http://man7.org/linux/man-pages/man7/signal.7.html[signal handlers],
         and as such may not mix well with other libraries which rely on this functionality.+
         +
         Our goal is to move away from this implementation detail eventually, however we can not commit at this point yet
         as to when other `unwind` mechanisms would arrive in Swift itself. These would in turn allow implementing these
         in a more compatible fashion.




[[failure-isolation]]
=== Failure isolation

NOTE: Failure isolation across nodes is simple, as such processes by design do not share memory and only communicate
      using messages over the network, the failure of one component is already isolated thanks to the network boundary. +
      +
      We do however have the ability to detect and react to node failures, which we'll discuss in the <<cluster>> section
      of the guide.

[[supervision_tree]]
=== Supervision hierarchies

Swift Distributed Actors enforces a strict parent-child relationship between actors. Only an actor's parent actor MAY supervise it.
Other actors - be it siblings or other completely unrelated actors - may only _watch_ a given actor for termination.

This leads to the formation of so called supervision hierarchies or supervision "trees".
It also allows us to structure our applications in ways that represent their _fault domains_.

TODO: explain bulk heading and compartmentalization.

=== A word of caution: fatal faults

Swift Distributed Actors does NOT allow recovering from "fatal faults" such as segmentation faults (segfaults) or similar faults.
Some faults are serious enough that continuing running after they have occurred is too risky and should not be taken lightly.

At the same time, bear in mind that while it may be possible to recover from some faults using Swift Distributed Actors, it may not be the best course of action,
sometimes faults are legitimate problems and can leave your system vulnerable. Make sure to always investigate fault crashes
of your actors and aim to build systems where faults do not occur on regular basis.

==== Supervising specific Errors

It is also possible to constrain which type of failure a supervisor should supervise. For example, when working with APIs
that might throw errors when they are "overwhelmed" and our goal is simply to drop the message which caused this fault,
yet do not terminate the actor but continue processing other messages as they are independent requests, we might want to
supervise only for this `SomeLibraryOverloadedError`, yet leave all other errors to crash the actor and leave any compensating
actions to its parent.

// TODO snippets, explain that the match must be EXACT, we do not perform any "is subclass of" checks etc.
// TODO: We COULD, but then we have to make the Supervisor<Message, Error>

While this mechanism is useful, it should _not_ be used to replace traditional `do/catch` blocks which usually are much
better positioned to perform appropriate cleanup or compensating actions closer to the origin of the issue. For example
one might want to a connection or file before stopping the actor cleanly, or performing the cleanup and causing the actor
to crash by throwing a different Error which then can carry more contextual information about why this crash happened,
which can be useful in later diagnosis and fixing of the issue.

NOTE: Supervision is not intended to replace `do/catch` blocks, and should be used for "unexpected" failures.
      Try to use the "let it crash" philosophy when designing your actors and their interactions.
      Make sure that a crash would carry enough useful information to be able to attempt fixing it later on,
      e.g. by carrying trace or similar metadata which could help identify if the error exists only for a specific
      entity or situation.


=== Analysing Back Traces (Crash Logs)

When a fault occurs, Swift Distributed Actors will print a crash log. An excellent talk from WWDC 2018 titled
https://developer.apple.com/videos/play/wwdc2018/414/["Understanding Crashes and Crash Logs"] is available and explains
how to read and use crash logs (backtraces) to locate and isolate problems in your code.

Another useful resource to understand crash logs is https://developer.apple.com/library/archive/technotes/tn2151/_index.html[Understanding and Analyzing Application Crash Reports].

=== Death Watch and Terminated signals

==== Guarantees

For the sake of describing those guarantees let us assume we have two actors, Romeo and Juliet.
Romeo performs a `context.watch(juliet)` during its `setup`.

It is by Swift Distributed Actors guaranteed that:

- if Juliet terminated Romeo will receive a `.terminated` signal which it can handle by using an `Behavior.receiveSignal`,
- the `.terminated` message will never be duplicated not lost. As it goes with system messages, one can assume "exactly once" processing for them,
including in distributed settings (which is a stronger guarantee than given for plain user messages),
-

Furthermore, if we imagine the above two actors be in the actual play of Shakespeare, then there would also be an audience,
which would be watching both of these actors. This means that many actors (the audience) can be watching out "stage" actors.
For this situation the following is guaranteed:

- if an actor (any actor) is watching any of the terminating actors it WILL receive an `.terminated` message,
- all of the actors watching a terminating actor WILL receive the `.terminated` message,
  - even in distributed settings, if a watcher has "not noticed immediately" what was going on on stage (e.g. due to lack of network connectivity),
    once it is informed by other actors (handled internally via cluster gossip), it will receive the outstanding `.terminated` as-if it had observed the death with its own eyes.

#TODO: complete this section#
