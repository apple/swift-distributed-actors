== Actors

TODO: This is just placeholders. Not actual structure etc.

=== Minimal example

TODO

=== "Thinking in Actors"

TODO super important section.

We should avoid "omg everything as an actor!" when people start adopting this :-)

=== Starting and stopping Actors

[source, swift]
----
include::{dir_sact_doc_tests}/ActorDocExamples.swift[tag=spawn]
----
<1> All Actors "live" within an `ActorSystem`, so in order to work with actors we need to first start a system.
<2> An actor's "Behavior" contains all the logic and state that it will work with. There are numerous ways to define one, we'll learn about them very soon.
<3> We `spawn` our actor using the `behavior` and we give it a `name` while we are at it as well. Names are tremendously helpful for understanding and debugging your application.
<4> We "tell" our actor our name, so that it can greet us. This is an asynchronous fire-and-forget message send to the actor.

=== Sending messages

TODO

=== Stopping actors

==== Guarantees

For a given actor, the following is guaranteed:

- if an actor returns the `.stopped` behavior, no further messages will be delivered to its message (or signal) receive blocks.
- if any other actors have been watching this actor, they will be informed about its termination using `.terminated` messages.

Internal guarantees:

- if the `.stopped` behavior is returned during handling system messages, no further user messages shall be processed.
- all pending (system) already enqueued to the actors mailboxes messages SHOULD be drained to dead letters or dropped.
- once the `.stopped` behavior is returned the actor should immediately be treated as `TERMINATING` yet it is not yet `CLOSED` (dead),
  - during the time between `TERMINATING` and `CLOSED` the actor performs shut down logic, such as notifying the parent actor or any watchers about its death.
  - all incoming messages, which hit an "at-least-TERMINATING" actor shall be immediately be DROPPED, without being enqueued at all. This is to avoid waking up the actor infinitely.
- resources (e.g. the held behavior) shall only be released once the CLOSED state has been reached.

Parent-child relationships add a few more guarantees:

- a parent is always notified about its child's failures
  - these DO NOT cause it to kill itself
- if the parent spawns AND watches the child though, the same death pact principles apply,
  and a failing child WILL cause the parent to terminate as well.

==== Stopping the current actor

Has to be performed by returning `Behavior.stopped` from a receive block.
This synchronously guarantees that no further messages will be processed after this stopped is returned.

NOTE: that one MAY NOT use the `context.stop(child:)` function to stop `myself`.

==== Stopping child actors

A parent actor may stop child actors by using `context.stop(child:)` on them,
which is implemented as a system message send asking the child to stop.

The child MAY NOT refuse such stop command and it is effective immediately once the message arrives at the child actor.
Bear in mind though that this stopping operation, by virtue of being a message send, is an asynchronous operation.

=== Monitoring and reacting to Termination

TODO

=== DeathWatch

==== Guarantees

For the sake of describing those guarantees let us assume we have two actors, Romeo and Juliet.
Romeo performs a `context.watch(juliet)` during its `setup`.

It is by Swift Distributed Actors guaranteed that:

- if Juliet terminated Romeo will receive a `.terminated` signal which it can handle by using an `Behavior.receiveSignal`,
- the `.terminated` message will never be duplicated not lost. As it goes with system messages, one can assume "exactly once" processing for them,
including in distributed settings (which is a stronger guarantee than given for plain user messages),
-

Furthermore, if we imagine the above two actors be in the actual play of Shakespeare, then there would also be an audience,
which would be watching both of these actors. This means that many actors (the audience) can be watching out "stage" actors.
For this situation the following is guaranteed:

- if an actor (any actor) is watching any of the terminating actors it WILL receive an `.terminated` message,
- all of the actors watching a terminating actor WILL receive the `.terminated` message,
  - even in distributed settings, if a watcher has "not noticed immediately" what was going on on stage (e.g. due to lack of network connectivity),
    once it is informed by other actors (handled internally via cluster gossip), it will receive the outstanding `.terminated` as-if it had observed the death with its own eyes.
