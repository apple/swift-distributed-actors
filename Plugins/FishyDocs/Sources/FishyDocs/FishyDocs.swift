import Markdown
import Foundation
import ArgumentParser

func log(_ log: String, file: String = #fileID, line: UInt = #line) {
    print("[fishy-docs] \(log)")
}

@main
struct FishyDocs: ParsableCommand {

    @Option(help: "Folder containing the docc documentation to scan for fishy-docs")
    var doccFile: String

    @Option(help: "Where to generate the sources")
    var outputFile: String

    mutating func run() throws {
        let fileName = doccFile
        let testFileName = outputFile

        // we always have to create the target file... since we're a .buildPlugin
        // even if we won't generate anything into it.
        FileManager.default.createFile(atPath: "\(testFileName)", contents: nil)


        guard let doccFileURL = URL(string: "file://\(doccFile)") else {
            log("Failed to parse: \(doccFile)")
            return
        }
        let document = try Document(parsing: doccFileURL)

        guard usesFishyDocs(document: document) else {
            return
        }

        guard let code = try makeDocsTestCode(document: document, doccFileName: fileName) else {
            return
        }

        log("Writing \(fileName) -> \(testFileName)")
        try code.write(toFile: "\(testFileName)", atomically: true, encoding: .utf8)
    }

    func usesFishyDocs(document: Document) -> Bool {
        var detectFishyDocs = DetectFishyDocs()
        detectFishyDocs.visit(document)

        return detectFishyDocs.detected
    }

    func makeDocsTestCode(document: Document, doccFileName: String) throws -> String? {
        var concatCodeBlocks = ConcatCodeBlocks()
        concatCodeBlocks.visit(document)

        guard !concatCodeBlocks.code.isEmpty else {
            return nil
        }

        var output = "// ==== Concat CodeBlocks from '\(doccFileName)' -----------------------------\n"
        output += "// DO NOT EDIT THIS FILE AS IT WILL BE RE-GENERATED BY FISHY-DOCS PLUGIN.\n"
        output += "// To edit snippets in this file, edit \(doccFileName) instead.\n"
        output += "\n"
        output += concatCodeBlocks.code

        return output
    }
}

/// Detects a `fishy-docs:enable` `@Comment` in a docc file, enabling the plugin for the given file.
struct DetectFishyDocs: MarkupWalker {
    var detected: Bool = false

    mutating func visitParagraph(_ paragraph: Paragraph) {
        detected = detected || paragraph.plainText.contains("fishy-docs:enable")
    }
}

struct ConcatCodeBlocks: MarkupWalker {

    var importBlocks: [CodeBlock] = []
    var codeBlocks: [CodeBlock] = []
    var code: String {
        var allBlocks = importBlocks
        allBlocks.append(contentsOf: codeBlocks)

        var codeBlockStrings: [String] = []
        for block in importBlocks {
            codeBlockStrings.append(block.code)
        }

        codeBlockStrings.append("func __test() async throws {")
        for block in codeBlocks {
            var s = "// ==== "

            var fileNameWasSet = false
            if let range = block.range {
                let startLoc = range.lowerBound
                if let fileName = startLoc.source!.pathComponents.split(separator: "/").last?.last {
                    fileNameWasSet = true
                    s += "\(fileName):\(startLoc.line)"
                }
            }

            if !fileNameWasSet {
                s += " <unknown loc>"
            }

            s += " ----------------------------------------\n"
            s += block.code

            codeBlockStrings.append(s)
        }
        codeBlockStrings.append("}") // end of __test()


        return codeBlockStrings.joined(separator: "\n")
    }

    mutating func visitCodeBlock(_ codeBlock: CodeBlock) {
        if codeBlock.code.contains("import ") {
            self.importBlocks.append(codeBlock)
        } else {
            self.codeBlocks.append(codeBlock)
        }
    }
}
